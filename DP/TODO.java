/**
 Fibonacci-dp Easy
 Climb Stairs Easy
 Climb Stairs With Variable Jumps Easy
 Climb Stairs With Minimum Moves Easy
 Min Cost In Maze Traversal Easy
 Goldmine Easy
 Target Sum Subsets - Dp Medium
 Coin Change Combination Easy
 Coin Change Permutations Medium
 Zero One Knapsack Easy
 Unbounded Knapsack Easy
 Fractional Knapsack - Official Easy
 Count Binary Strings Easy
 Arrange Buildings Easy
 Count Encodings Easy
 Count A+b+c+ Subsequences Easy
 Maximum Sum Non Adjacent Elements Easy
 Paint House Easy
 Paint House - Many Colors Easy
 Paint Fence Easy
 Tiling With 2 * 1 Tiles Easy
 Tiling With M * 1 Tiles Easy
 Friends Pairing Easy
 Partition Into Subsets Easy
 Buy And Sell Stocks - One Transaction Allowed Easy
 Buy And Sell Stocks - Infinite Transactions Allowed Easy
 Buy And Sell Stocks With Transaction Fee - Infinite Transactions Allowed Medium
 Buy And Sell Stocks With Cooldown - Infinite Transaction Allowed Medium
 Buy And Sell Stocks - Two Transactions Allowed Easy
 Buy And Sell Stocks - K Transactions Allowed Easy

 Longest Increasing Subsequence Medium
 Maximum Sum Increasing Subsequence Easy
 Longest Bitonic Subsequence Easy
 Maximum Non-overlapping Bridges Easy
 Russian Doll Envelopes Hard
 Min Squares Easy
 Longest Common Subsequence Medium
 Longest Palindromic Subsequences Medium
 Count Palindromic Subsequences Hard
 Count Palindromic Substrings Medium
 Longest Palindromic Substring Medium
 Count Distinct Subsequences Easy
 Count Of Distinct Palindromic Subsequences Medium
 Print All Longest Increasing Subsequences Easy
 Print All Paths With Minimum Jumps Medium
 Print All Paths With Minimum Cost Medium
 Print All Paths With Maximum Gold Medium
 Print All Paths With Target Sum Subset Medium
 Print All Results In 0-1 Knapsack Medium
 Wildcard Pattern Matching Medium
 Regular Expression Matching Hard
 Catalan Number Easy
 Number Of Bsts Medium
 Count Of Valleys And Mountains Easy
 Count Brackets Easy
 Circle And Chords Easy
 Number Of Ways Of Triangulation Easy
 Minimum Score Of Triangulation Medium
 Catalan Numbers Variation
 Rod Cutting Easy
 Minimum Palindromic Cut Easy
 Matrix Chain Multiplication Medium
 Boolean Parenthesization Easy
 Optimal Binary Search Tree Easy
 Burst Balloons Hard
 Longest Common Substring Easy
 Longest Repeating Subsequence Medium
 Minimum Ascii Delete Sum For Two Strings Medium
 Minimum Cost To Make Two Strings Identical Easy
 Shortest Uncommon Subsequence Medium
 Distinct Transformations Medium
 Probability Of Knight In The Chessboard Medium
 Edit Distance Hard
 Kadane's Algorithm Easy
 K Concatenation Medium
 Maximum Sum Subarray With At Least K Elements Medium
 Numeric Keypad Medium
 Maximum Difference Of Zeros And Ones In Binary String Easy
 Maximum Sum Of Two Non-overlapping Subarrays Medium
 Optimal Strategy For A Game Easy
 Egg Drop Hard
 Maximum Sum Of Three Non-overlapping Subarrays Hard
 Maximum Sum Of M Non-overlapping Subarrays Hard
 Floor Tiling - 2 Medium
 Cherry Pickup Hard
 Scramble String Hard
 Lcs Of Three Strings Medium
 Arithmetic Slices 1 Medium
 Arithmetic Slices 2 Hard
 Word Break 2 Medium
 Word Wrap Medium
 2 Key Keyboard Medium
 4 Key Keyboard Hard
 Largest Square Sub-matrix With All 1's Medium
 Highway Billboard Medium
 Temple Offerings Medium
 Alternating Subsequence With Maximum Sum Medium
 Minimum Insertions To Make Palindrome Easy
 Minimum Delta In Partitions Medium
 Minimum Number Of Steps To Reduce N Easy
 Minimum Number Of Steps To Form N Easy
 Linear Equation Of N Variables Medium
 Minimum Deletions To Make Palindromic Sequence Easy
 Minimum Deletions To Make Sorted Array Easy
 Min Max Value Expression Easy



questions iconUgly Numbers
questions iconSuper Ugly Number Number Whose Prime Factors Given Set
questions iconMaximum Size Sub Matrix With All 1S In A Binary Matrix
questions iconDynamic Programming Subset Sum Problem
questions iconMinimum Number Of Jumps To Reach End Of A Given Array
questions iconDynamic Programming Set 15 Longest Bitonic Subsequence
questions iconMaximum Sum Bi Tonic Sub Sequence
questions iconLcs Longest Common Subsequence Three Strings
questions iconFriends Pairing Problem
questions iconDynamic Programming Building Bridges
questions iconDynamic Programming Set 18 Partition Problem
questions iconCount Number Of Ways To Partition A Set Into K Subsets
questions iconDynamic Programming Set 12 Longest Palindromic Subsequence
questions iconDynamic Programming Set 11 Egg Dropping Puzzle
questions iconDynamic Programming Set 21 Box Stacking Problem
questions iconDynamic Programming Set 24 Optimal Binary Search Tree
questions iconDynamic Programming Set 28 Minimum Insertions To Form A Palindrome
questions iconDynamic Programming Set 36 Cut A Rope To Maximize Product
questions iconDynamic Programming Set 31 Optimal Strategy For A Game
questions iconDynamic Programming Set 32 Word Break Problem
questions iconMobile Numeric Keypad Problem
questions iconFind Number Of Solutions Of A Linear Equation Of N Variables
questions iconCount Number Ways Tile Floor Size N X M Using 1 X M Size Tiles
questions iconCount Number Binary Strings Without Consecutive 1S
questions iconPainters Partition Problem
questions iconCheck Whether A Given String Is An Interleaving Of Two Other Given Strings Set 2
questions iconWildcard Pattern Matching
questions iconProbability Knight Remain Chessboard
questions iconTwo Water Jug Puzzle
questions iconDynamic Programming Set 18 Word Wrap
questions iconLargest Sum Subarray Least K Numbers
questions iconFind Water In A Glass
questions iconRemove Minimum Elements Either Side 2Min Max
questions iconNumber Subsequences Form Ai Bj Ck
questions iconUnbounded Knapsack Repetition Items Allowed
questions iconLength Of The Longest Valid Substring
questions iconDynamic Programming Set 37 Boolean Parenthesization Problem
questions iconCount Possible Decodings Given Digit Sequence
questions iconPerfect Sum Problem Print Subsets Given Sum
questions iconVertex Cover Problem Set 2 Dynamic Programming Solution Tree
questions iconLongest Even Length Substring Sum First Second Half
questions iconCount Possible Ways To Construct Buildings
questions iconBitmasking And Dynamic Programming Set 1 Count Ways To Assign Unique Cap To Every Person
questions iconLongest Repeating Subsequence
questions iconLongest Common Increasing Subsequence Lcs Lis
questions iconFind If String Is K Palindrome Or Not
questions iconMinimum Sum Path 3 D Array
questions iconCount Distinct Subsequences
questions iconShortest Uncommon Subsequence
questions iconTemple Offerings
questions iconHighway Billboard Problem
questions iconMaximum Sum Alternating Subsequence Sum
questions iconMinimum Maximum Values Expression
questions iconMinimum And Maximum Values Of An Expression With * And +

Maximum Sum Increasing Subsequence
//  Wildcard Character Matching
Print Shortest Common Supersequence
Print Longest Common Sub Sequences Lexicographical Order
Count Binary Strings K Times Appearing Adjacent Two Set Bits
Count Ways Increase Lcs Length Two Strings One
Find Number Times String Occurs Given String
Count Distinct Subsequences
Number of subsequences in a string divisible by n
Word Wrap Problem [VERY IMP].
EDIT Distance [Very Imp]
Word break Problem[ Very Imp]
Write a program to find the longest Palindrome in a string.[ Longest palindromic Substring]
Find Longest Recurring Subsequence in String
Count All Palindromic Subsequence in a given String.
Program to generate all possible valid IP addresses from given  string.
Minimum no. of Jumps to reach end of an array
 */


/* 
public class l003_TargetSet{


    public static int coinChangePermutation(int[] arr,int tar,int[] dp){
        if(tar == 0){
            return dp[tar] = 1;
        }
        
        if(dp[tar]!=0) return dp[tar];

        for(int ele : arr){
            if(tar - ele >= 0){
                dp[tar] += coinChangePermutation(arr,tar-ele,dp);
            }
        }
        return dp[tar];
    }
 
    public static int coinChangePermutationDP(int[] arr,int Tar,int[] dp){
        dp[0] = 1;
        for(int tar = 1; tar <= Tar; tar++){
            for(int ele : arr){
                if(tar - ele >= 0){
                    dp[tar] += dp[tar-ele];
                }
            }            
        }

        return dp[Tar];
    }

    public static int coinChangeCobinationDP(int[] arr,int Tar,int[] dp){
        dp[0] = 1;
        for(int ele : arr){
            for(int tar = ele; tar <= Tar; tar++){
                    dp[tar] += dp[tar-ele];
            }            
        }

        return dp[Tar];
    }

    //Leetcode 377  -> coinChangePermutationDP

    //Leetcode 322

    public int minCoinsRequired(int[] arr, int tar,int[] dp) {
        if(tar == 0){
            return 0;
        }

        if(dp[tar] != -1) return dp[tar];

        int minCoin = (int)1e9;
        for(int ele : arr){
            if(tar - ele >= 0 ){
                int val = minCoinsRequired(arr,tar - ele,dp);
                if(val != (int)1e9 && val + 1 < minCoin)
                   minCoin = val + 1;
            }
        }

        return dp[tar] = minCoin;
    }

    public int minCoinsRequiredDP(int[] arr, int Tar,int[] dp){
        dp[0] = 0;
        for(int tar = 1; tar<=Tar;tar++){
            int minCoin = (int)1e9;
            for(int ele : arr){
                if(tar - ele >= 0 ){
                    int val = dp[tar - ele];
                    if(val != (int)1e9 && val + 1 < minCoin)
                       minCoin = val + 1;
                }
            }
            dp[tar] = minCoin;
        }
        return dp[Tar];
    }

    public int coinChange(int[] coins, int amount) {
        int[] dp=new int[amount+1];
        Arrays.fill(dp,-1);

        int ans = minCoinsRequiredDP(coins,amount,dp);
        return ans != (int)1e9? ans: -1;
    }

    //https://www.geeksforgeeks.org/subset-sum-problem-dp-25/

    public static int targetSum(int[] arr,int idx,int tar,int[][] dp){
        if(tar == 0 || idx == arr.length){
            return dp[idx][tar] = tar == 0 ? 1 : 0;
        }

        if(dp[idx][tar] != -1) return dp[idx][tar];

        int count = 0;
        if(tar - arr[idx] >= 0)
          count += targetSum(arr,idx+1,tar - arr[idx], dp);
        count += targetSum(arr,idx+1,tar, dp);

        return dp[idx][tar] = count;
    }

    public static int targetSumDP(int[] arr,int Idx,int Tar,int[][] dp){
        for(int idx = arr.length;idx >= 0;idx--){
            for(int tar = 0;tar<=Tar;tar++){
                if(tar == 0 || idx == arr.length){
                    dp[idx][tar] = (tar == 0) ? 1 : 0;
                    continue;
                }
                
                int count = 0;
                if(tar - arr[idx] >= 0)
                   count += dp[idx + 1][tar-arr[idx]];
                count += dp[idx + 1][tar];
               
                dp[idx][tar] = count;
            }
        }

        return dp[Idx][Tar];
    }


    public static int targetSum2(int[] arr,int n,int tar,int[][] dp){
        if(tar == 0 || n == 0){
            return dp[n][tar] = (tar == 0) ? 1 : 0;
        }

        if(dp[n][tar] != -1) return dp[n][tar];

        int count = 0;
        if(tar - arr[n - 1] >= 0)
          count += targetSum2(arr,n - 1,tar - arr[n - 1], dp);
        count += targetSum2(arr,n - 1,tar, dp);

        return dp[n][tar] = count;
    }

    public static int targetSumDP2(int[] arr,int N,int Tar,int[][] dp){
        for(int n = 0;n<=N;n++){
            for(int tar = 0;tar<=Tar;tar++){
                if(tar == 0 || n == 0){
                    dp[n][tar] = (tar == 0) ? 1 : 0;
                    continue;
                }
                
                int count = 0;
                if(tar - arr[n - 1] >= 0)
                   count += dp[n-1][tar-arr[n-1]];
                count += dp[n-1][tar];
               
                dp[n][tar] = count;
            }
        }

        return dp[N][Tar];
    }

    public static boolean targetSumPath(int[] arr,int n,int tar,int[][] dp,String psf){
        if(tar == 0 || n == 0){
           if(tar == 0){
            System.out.println(psf);
            return true;
           }
           return false;
        }

        boolean res = false;
        if(tar - arr[n - 1] >= 0 && dp[n-1][tar - arr[n-1]] > 0)
          res = res || targetSumPath(arr,n - 1,tar - arr[n - 1], dp, psf + arr[n-1] + ",");
        if(dp[n-1][tar] > 0) res = res || targetSumPath(arr,n - 1,tar, dp,psf);

        return res;
    }

    public static void targetSum(){
        int[] arr = {2,3,5,7};
        int tar = 10;

        int[][] dp = new int[arr.length+1][tar+1];
        // for(int[] d: dp) Arrays.fill(d,-1);
        // int ans = targetSumDP(arr,0,tar,dp);

        int ans = targetSumDP2(arr,arr.length,tar,dp);
        System.out.println(targetSumPath(arr,arr.length,tar,dp,""));

        print2D(dp);
    }

    //416
    public boolean canPartition(int[] arr) {
        int N = arr.length;
        if(N==0) return false;

        int sum = 0;
        for(int ele : arr) sum+=ele;
        if(sum % 2 != 0) return false;

        int Tar = sum / 2;
        boolean[][] dp = new boolean[N + 1][Tar + 1];

        for(int n = 0;n<=N;n++){
            for(int tar = 0;tar<=Tar;tar++){
                if(tar == 0 || n == 0){
                    dp[n][tar] = (tar == 0) ? true : false;
                    continue;
                }
                
                int count = 0;
                if(tar - arr[n - 1] >= 0)
                   dp[n][tar] = dp[n][tar] || dp[n-1][tar-arr[n-1]];
                dp[n][tar] = dp[n][tar] ||  dp[n-1][tar];               
            }
        }

        return dp[N][Tar];
    }

    //https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/
    public static int knapsack01(int[] weight,int[] value,int n,int tar,int[][] dp){
        if(n == 0 || tar == 0){
            return dp[n][tar] = 0;
        }

        if(dp[n][tar] != -1) return dp[n][tar];

        int maxValue = 0;
        if(tar - weight[n - 1] >= 0)
           maxValue = knapsack01(weight,val,n - 1,tar - weight[n - 1],dp) + value[n - 1];
        maxValue = Math.max(maxValue, knapsack01(weight,val,n - 1,tar,dp))
        
        return dp[n][tar] = maxValue;
    }

    //https://www.geeksforgeeks.org/unbounded-knapsack-repetition-items-allowed/
    public static int nboundedCost(int[] weight,int[] val,int Tar){
        int[] dp = new int[tar+1];
        for(int i = 0;i<weight.length;i++){   
           for(int tar = weight[i];tar <= Tar;tar++){
               dp[tar] = Math.max(dp[tar],dp[tar - weight[i]] + val[i]);
           }
        }

        return dp[Tar];
    }

    //for you -> https://www.geeksforgeeks.org/find-number-of-solutions-of-a-linear-equation-of-n-variables/
    
    // 494
    public int findTargetSumWays(int[] nums, int tar,int n,int sum,int[][] dp) {
        if(n == 0){
            return dp[n][sum] = (tar == sum)? 1: 0;
        }

        if(dp[n][sum] != -1) return dp[n][sum];

        int count = 0;
        count += findTargetSumWays(nums,tar,n-1,sum + nums[n-1],dp); // positive number
        count += findTargetSumWays(nums,tar,n-1,sum + (-nums[n-1]),dp); // negative number

        return dp[n][sum] = count;
    }
    
    
    public int findTargetSumWays(int[] nums, int S) {
        int n = nums.length;
      
        if(n == 0) return 0; 
        
        int sum = 0;
        for(int ele : nums) sum+=ele;
        if(S > sum || S < -sum) return 0;
        int[][] dp = new int[n+1][2 * sum + 1];
        for(int[] d: dp) Arrays.fill(d,-1);
        int ans = findTargetSumWays(nums,(S + sum),n,(0 + sum),dp);

        return ans;
    }


    public static void solve(){
        targetSum();
    }


    public static void main(String[] args){
        solve();
    }
}

import java.util.Arrays;
import java.util.LinkedList;

public class l002_StringSet{
    public static void print(int[] arr){
        for(int ele: arr)
          System.out.print(ele + " "); 
        
        System.out.println();
    }

    public static void print2D(int[][] arr){
        for(int[] a: arr)
          print(a);

        System.out.println();
    }

    public static void palindromicSubstring(String str,boolean[][] dp){
        int n = str.length();
        for(int gap = 0;gap < n;gap++){
            for(int i=0,j=gap; j < n;i++,j++){
                if(gap == 0) dp[i][j] = true;
                else if(gap == 1) dp[i][j] = str.charAt(i) == str.charAt(j);
                else dp[i][j] = str.charAt(i) == str.charAt(j)  && dp[i+1][j-1];
            }
        }
    } 


    //Leetcode 647
    public int countSubstrings(String s) {
        int n = str.length();
        boolean[][] dp = new boolean[n][n];
        int count = 0; 
        for(int gap = 0;gap < n;gap++){
            for(int i=0,j=gap; j < n;i++,j++){
                if(gap == 0) dp[i][j] = true;
                else if(gap == 1) dp[i][j] = str.charAt(i) == str.charAt(j);
                else dp[i][j] = str.charAt(i) == str.charAt(j)  && dp[i+1][j-1];
            
                if(dp[i][j]) count++; 
            }
        }
        return count;
    }

    // Leetcode 005
    public String longestPalindrome(String str) {
        int n = str.length();
        int[][] dp = new int[n][n];
        
        int si = 0,ei = 0,length = 0; // starting index, ending index of longest palindromic susbtring.
        
        for(int gap = 0;gap < n;gap++){
            for(int i=0,j=gap; j < n;i++,j++){

                if(gap == 0) dp[i][j] = 1;
                else if(gap == 1 && str.charAt(i) == str.charAt(j)) dp[i][j] = 2;
                else if(str.charAt(i) == str.charAt(j) && dp[i+1][j-1] > 0) dp[i][j] = dp[i+1][j-1] + 2;
            
                if(dp[i][j] > length){
                    length = dp[i][j];
                    si = i;
                    ei = j;
                } 
            }
        }

        return str.substring(si,ei+1);
    }

    // Leetcode 516
    
    public int longestPalindromeSubseq(String s,int i,int j,int[][] dp) {
        if( i > j || i == j) return dp[i][j] = (i == j) ? 1: 0;

        if(dp[i][j]!=0) return dp[i][j];

        if(s.charAt(i) == s.charAt(j)) dp[i][j] = longestPalindromeSubseq(s,i+1,j-1,dp) + 2;
        else dp[i][j] = Math.max(longestPalindromeSubseq(s,i+1,j,dp),longestPalindromeSubseq(s,i,j-1,dp));

        return dp[i][j];
    }

    
    public int longestPalindromeSubseqDP(String s,int I,int J,int[][] dp) {
        int n = s.length();
        String[][] sdp = new String[n][n];
        for(String[] d: sdp) Arrays.fill(d,"");

        for(int gap = 0;gap<n;gap++){
            for(int i=0,j=gap;j<n;i++,j++){
                
                if(i == j) {
                    dp[i][j] = (i == j) ? 1: 0;
                    sdp[i][j] = s.charAt(i) + "";
                    continue;
                }

                if(s.charAt(i) == s.charAt(j)){
                    dp[i][j] = dp[i+1][j-1] + 2;
                    sdp[i][j] = s.charAt(i) + sdp[i+1][j-1] +s.charAt(i);
                }
                else{
                    if(dp[i+1][j] > dp[i][j-1]){
                        dp[i][j] = dp[i+1][j];
                        sdp[i][j] = sdp[i+1][j];
                    }else{
                        dp[i][j] = dp[i][j-1];
                        sdp[i][j] = sdp[i][j-1];
                    }
                }               
            }
        }

        return dp[I][J];
    }

     // ls = left palindrome string,rs = right palindrome string
     public static void generateString(int[][] dp,String s,int i,int j,LinkedList<Character> ls,LinkedList<Character> rs){
        if(i > j || i == j){
            if(i==j){
                ls.addLast(s.charAt(i));
            }

            System.out.print(ls);
            System.out.print(rs);
            System.out.println();
            
            if(i==j){
                ls.removeLast();
            }
 
            return;
        }

        if(s.charAt(i) == s.charAt(j)){            
            ls.addLast(s.charAt(i));
            rs.addFirst(s.charAt(i));

            generateString(dp,s,i+1,j-1,ls,rs);

            ls.removeLast();
            rs.removeFirst();
        } 
        else{

            if(dp[i+1][j] > dp[i][j-1]) generateString(dp,s,i+1,j,ls,rs);
            else if(dp[i+1][j] < dp[i][j-1]) generateString(dp,s,i,j-1,ls,rs);
            else{
                generateString(dp,s,i,j-1,ls,rs);
                generateString(dp,s,i+1,j,ls,rs);
            }
        }
    }

    public static void generateString(int[][] dp,String s,int i,int j,String ls,String rs){
        if(i > j || i == j){
            if(i==j){
                ls += s.charAt(i);
            }
            System.out.println(ls + rs);
            return;
        }

        if(s.charAt(i) == s.charAt(j)){            
            generateString(dp,s,i+1,j-1,ls + s.charAt(i),s.charAt(i) + rs);
        } 
        else{
            if(dp[i+1][j] > dp[i][j-1]) generateString(dp,s,i+1,j,ls,rs);
            else if(dp[i+1][j] < dp[i][j-1]) generateString(dp,s,i,j-1,ls,rs);
            // else{
            //     generateString(dp,s,i,j-1,ls,rs);
            //     generateString(dp,s,i+1,j,ls,rs);
            // }
        }
    }

    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] dp = new int[n][n];
        // int ans = longestPalindromeSubseq(s,0,n-1,dp);
        int ans = longestPalindromeSubseqDP(s,0,n-1,dp);

        return ans;
    }

    //Leetcode 115
    public int numDistinct(String s, String t,int n,int m,int[][] dp){
        if(m == 0){
            return dp[n][m] = 1;
        }

        if(n < m){
            return dp[n][m] = 0;
        }

        if(dp[n][m] != -1) return dp[n][m];

        int count = 0;
        if(s.charAt(n-1) == t.charAt(m-1)){
            count += numDistinct(s,t,n-1,m-1,dp);
            count += numDistinct(s,t,n-1,m,dp);   
        }else
            count += numDistinct(s,t,n-1,m,dp);

        return dp[n][m] = count;
    }

    public int numDistinctDP(String s, String t,int N,int M,int[][] dp){
        for(int n = 0;n <= N;n++){
            for(int m = 0; m <= M;m++){
                if(m == 0){
                    dp[n][m] = 1;
                    continue;
                }
        
                if(n < m){
                    dp[n][m] = 0;
                    continue;
                }
        
                int count = 0;
                if(s.charAt(n-1) == t.charAt(m-1)){
                    count += dp[n-1][m-1];
                    count += dp[n-1][m];   
                }else
                    count += dp[n-1][m];
        
                dp[n][m] = count;
            }
        }

        return dp[N][M];
    }

    public int numDistinct(String s, String t){
        int n = s.length();
        int m = t.length();
        int[][] dp = new int[n+1][m+1];

        for(int[] d:dp) Arrays.fill(d,-1);
        int ans = numDistinct(s,t,n,m,dp);
        return ans;
    }

    // https://practice.geeksforgeeks.org/problems/count-palindromic-subsequences/1
    public int countPS(String str,int i,int j,int[][] dp)
    {
        if(i >= j ){
            return dp[i][j] = (i == j)?1:0;
        }
        if(dp[i][j]!=0) return dp[i][j];
        
        int x = countPS(str,i+1,j-1,dp);
        int y = countPS(str,i,j-1,dp);
        int z = countPS(str,i+1,j,dp);
        
        if(str.charAt(i) == str.charAt(j)) dp[i][j] = (x + 1) + (y + z - x); //(y + z + 1);
        else dp[i][j] = (y + z - x);
        
        return dp[i][j];
    }
    
    public int countPS_DP(String str,int I,int J,int[][] dp)
    {
        for(int gap = 0;gap < str.length();gap++){
            for(int i =0,j = gap; j < str.length();i++,j++){
        if(i >= j ){
            dp[i][j] = (i == j)?1:0;
            continue;
        }
        
        int x = dp[i+1][j-1];//countPS(str,i+1,j-1,dp);
        int y = dp[i][j-1];//countPS(str,i,j-1,dp);
        int z = dp[i+1][j];//countPS(str,i+1,j,dp);
        
        if(str.charAt(i) == str.charAt(j)) dp[i][j] = (x + 1) + (y + z - x); //(y + z + 1);
        else dp[i][j] = (y + z - x);
        
            }
        }
    
        return dp[I][J];
    }
    public  int countPS(String str)
    {
        int n = str.length();
        int[][] dp = new int[n][n];

        return (countPS_DP(str, 0, n - 1 , dp));
    }

    // Leetcode 1143
    public int longestCommonSubsequence(String s1, String s2,int n,int m,int[][] dp) {
        if(n==0 || m == 0) return 0;
        if(dp[n][m]!=-1) return dp[n][m];
        
        if(s1.charAt(n-1) == s2.charAt(m-1)) dp[n][m] = longestCommonSubsequence(s1,s2,n-1,m-1,dp) + 1;
        else dp[n][m] = Math.max(longestCommonSubsequence(s1,s2,n,m-1,dp),longestCommonSubsequence(s1,s2,n-1,m,dp));
        
        return dp[n][m];
    }

    public int longestCommonSubsequenceDP(String s1, String s2,int N,int M,int[][] dp) {
        for(int n=0;n<=N;n++){
            for(int m =0;m<=M;m++){
                if(n==0 || m == 0){
                    dp[n][m] = 0;
                    continue;
                }

                if(s1.charAt(n-1) == s2.charAt(m-1)) dp[n][m] = dp[n-1][m-1] + 1;
                else dp[n][m] = Math.max(dp[n][m-1],dp[n-1][m]);
            }
        }

        return dp[N][M];
    }
    
    public int longestCommonSubsequence(String s1, String s2) {
        int n = s1.length();
        int m = s2.length();
        
        int[][] dp = new int[n+1][m+1];
        // for(int[] d : dp) Arrays.fill(d,-1);
        
        return longestCommonSubsequenceDP(s1,s2,n,m,dp);
    }

    //1035
    public int maxUncrossedLines(int[] A, int[] B) {
        int N=A.length;
        int M=B.length;
        
        int[][] dp=new int[N+1][M+1];
    
        for(int n=0;n<=N;n++){
            for(int m=0;m<=M;m++){
                
                if(n==0|| m==0) {
                    dp[n][m]=0;
                    continue;
                }
                if(A[n-1]==B[m-1]) dp[n][m]=dp[n-1][m-1]+1;
                else dp[n][m]=Math.max(dp[n-1][m],dp[n][m-1]);
            }
            
        }
        
        return dp[N][M];
    }

    //Leetcode 72
    public int minDistance(String word1, String word2,int n,int m,int[][] dp) {
        if(n==0 || m==0){
            //if(n==0 && m==0) return dp[n][m] = 0;
            return dp[n][m] = n != 0 ? n : m;
        }

        if(dp[n][m] != 0) return dp[n][m];

        if(word1.charAt(n-1) == word2.charAt(m-1))dp[n][m] = minDistance(word1,word2,n-1,m-1,dp);
        else dp[n][m] = 1 + Math.min(Math.min(minDistance(word1,word2,n,m-1,dp),minDistance(word1,word2,n-1,m,dp)),minDistance(word1,word2,n-1,m-1,dp));
        
        return dp[n][m];
    }

    public int minDistanceDP(String word1, String word2,int N,int M,int[][] dp) {
        for(int n=0;n<=N;n++){
            for(int m=0;m<=M;m++){
                if(n==0 || m==0){
                    dp[n][m] = n != 0 ? n : m;
                    continue;
                }
        
                if(word1.charAt(n-1) == word2.charAt(m-1)) dp[n][m] = dp[n-1][m-1];
                else dp[n][m] = 1 + Math.min(Math.min( dp[n-1][m], dp[n][m-1]), dp[n-1][m-1]);
            }
        }

        return dp[N][M];
    }

    public int minDistance(String word1, String word2) {
        int n = word1.length();
        int m = word2.length();
        int[][] dp = new int[n+1][m+1];
        return minDistanceDP(word1,word2,n,m,dp);
    }

    // Leetcode 44
    public int isMatch(String s, String p,int n,int m,int[][] dp) {
        if(n == 0 || m == 0){
            if(n==0 && m == 0) return dp[n][m] = 1;
            else if(m == 1 && p.charAt(m-1) == '*') return dp[n][m] = 1;
            return dp[n][m]  = 0;
        }

        if(dp[n][m] != -1) return dp[n][m];

        char ch1 = s.charAt(n - 1);
        char ch2 = p.charAt(m - 1);
        int val = -1;
        if(ch1 == ch2 || ch2 == '?')  val = isMatch(s,p,n-1,m-1,dp);
        else if(ch2 == '*'){
            boolean res = false;
            res = res || (isMatch(s,p,n,m-1,dp) == 1);
            res = res || (isMatch(s,p,n-1,m,dp) == 1);

            val = res ? 1: 0;
        }else val = 0;

        return dp[n][m] = val;
    }

    public static String removeStar(String str){
        if(str.length() == 0) return "";
        StringBuilder sb = new StringBuilder();

        sb.append(str.charAt(0));
        int i = 1;
        while(i < str.length()){
            while(i < str.length() && str.charAt(i - 1) == '*'&& str.charAt(i) == '*') i++;
            
            if(i < str.length()) sb.append(str.charAt(i));
            i++;
        }

        return sb.toString();
    }

    public boolean isMatch(String s, String p) {
        p = removeStar(p);
        int n = s.length();
        int m = p.length();

        int[][] dp = new int[n + 1][m + 1];
        for(int[] d: dp) Arrays.fill(d,-1);

        return isMatch(s,p,n,m,dp) == 1;
    }
    
    public static void main(String[] args){


    }


}

public class l005_StockBuyAndSell{
     
    //121
    public int maxProfit(int[] arr) {
        if(arr.length==0) return 0;
        
        int Ti0 = 0;
        int Ti1 = -(int)1e9;

        for(int ele: arr){
            Ti0 = Math.max(Ti0,Ti1 + ele);
            Ti1 = Math.max(Ti1,0 - ele);
        }

        return Ti0;
    }

    //123
    public int maxProfit(int[] arr) {
        if(arr.length==0) return 0;

        int Ti20 = 0;
        int Ti21 = -(int)1e9;
        
        int Ti10 = 0;
        int Ti11 = -(int)1e9;

        for(int ele : arr){
            Ti20 = Math.max(Ti20, Ti21 + ele);
            Ti21 = Math.max(Ti21, Ti10 - ele);

            Ti10 = Math.max(Ti10, Ti11 + ele);
            Ti11 = Math.max(Ti11, 0 - ele);
        }

        return Ti20;
    }

    //122
    public int maxProfit(int[] arr) {
        if(arr.length==0) return 0;
        
        int Ti0 = 0;
        int Ti1 = -(int)1e9;

        for(int ele: arr){
            Ti0 = Math.max(Ti0,Ti1 + ele);
            Ti1 = Math.max(Ti1,Ti0 - ele);
        }

        return Ti0;
    }

    //714
    public int maxProfit(int[] prices, int fee) {
        int T0 = 0;
        int T1 = -(int)1e9;

        
        for(int ele: arr){
            int prevSell = Ti0;
            Ti0 = Math.max(Ti0,Ti1 + ele);
            Ti1 = Math.max(Ti1,prevSell - ele - fee);
        }

        return Ti0;
    }

    //309
    public int maxProfit(int[] arr) {
        if(arr.length==0) return 0;
    
        int Ti0 = 0;
        int Ti1 = -(int)1e9;
        int Ti2 = 0;
    
        for(int val : arr){
            int temp = Ti0;
            Ti0 = Math.max(Ti0,Ti1 + val);
            Ti1 = Math.max(Ti1,Ti2 - val);
            Ti2 = temp;
        }
    
        return T0;        
    }

    //188



}


import java.util.Arrays;
public class l006_CutType{

    public static int MCM(int[] arr,int si,int ei,int[][] dp){
        if(si + 1 == ei){
            return dp[si][ei] = 0;
        }

        if(dp[si][ei] != -1) return dp[si][ei];

        int minCost = (int)1e9;
        for(int cut = si + 1;cut < ei;cut++){
            int leftTree = MCM(arr,si,cut,dp);
            int rightTree = MCM(arr,cut,ei,dp);

            int costOfMultiplication = leftTree + (arr[si] * arr[cut] * arr[ei]) + rightTree;
            minCost = Math.min(minCost,costOfMultiplication);
        }

        return dp[si][ei] = minCost;
    }

    public static int MCM_DP(int[] arr,int SI,int EI,int[][] dp){
        int n = arr.length;
        for(int gap = 1;gap<n;gap++){
            for(int si = 0,ei = gap; ei < n;si++,ei++ ){
                if(si + 1 == ei){
                    dp[si][ei] = 0;
                    continue;
                }
                
                int minCost = (int)1e9;
                for(int cut = si + 1;cut < ei;cut++){
                    int leftTree = dp[si][cut];//MCM(arr,si,cut,dp);
                    int rightTree = dp[cut][ei];//MCM(arr,cut,ei,dp);
        
                    int costOfMultiplication = leftTree + (arr[si] * arr[cut] * arr[ei]) + rightTree;
                    minCost = Math.min(minCost,costOfMultiplication);
                }
        
                dp[si][ei] = minCost;
            }
        }

        return dp[SI][EI];
    }

    public static int MCM_DP_String(int[] arr,int SI,int EI,int[][] dp){
        int n = arr.length;
        String[][] sdp = new String[n][n];
        for(String[] s : sdp) Arrays.fill(s,"");

        for(int gap = 1;gap<n;gap++){
            for(int si = 0,ei = gap; ei < n;si++,ei++ ){
                if(si + 1 == ei){
                    dp[si][ei] = 0;
                    sdp[si][ei] = (char)(si + 'A') +"";
                    continue;
                }
                
                int minCost = (int)1e9;
                for(int cut = si + 1;cut < ei;cut++){
                    int leftTree = dp[si][cut];//MCM(arr,si,cut,dp);
                    int rightTree = dp[cut][ei];//MCM(arr,cut,ei,dp);
        
                    int costOfMultiplication = leftTree + (arr[si] * arr[cut] * arr[ei]) + rightTree;
                    if(costOfMultiplication < minCost){
                        minCost = costOfMultiplication;
                        sdp[si][ei] = "(" + sdp[si][cut] + sdp[cut][ei] + ")";
                    }
                }
        
                dp[si][ei] = minCost;
            }
        }
        
        System.out.println(sdp[SI][EI]);
        return dp[SI][EI];
    }



    public static void MCM(){

        int[] arr = {10, 20, 30, 40, 30};
        int n = arr.length;
        int[][] dp = new int[n][n];
        int  ans = MCM_DP_String(arr,0,n-1,dp);

        System.out.println(ans);
    }

    //https://www.geeksforgeeks.org/minimum-maximum-values-expression/
    public static class pair{
        int minVal = 0;
        int maxVal = 0;

        pair(int minVal,int maxVal){
            this.minVal = minVal;
            this.maxVal = maxVal;
        }
    }

    public static int Evaluate(char ch, int a,int b){
        if(ch == '*') return a*b;
        else return a+b;
    }


    public static pair minMaxEvaluation(int[] num,char[] operator,int si,int ei,pair[][] dp){
        if(si == ei){
            return new pair(num[si],num[si]);
        }
        if(dp[si][ei] != null) return dp[si][ei];

        pair myAns = new pair((int)1e9,-(int)1e9);
        for(int cut = si; cut < ei; cut++){
            pair left = minMaxEvaluation(num,operator,si,cut,dp);
            pair right = minMaxEvaluation(num,operator,cut+1,ei,dp);

            char ch = operator[cut];

            myAns.minVal = Math.min(myAns.minVal, Evaluate(ch,left.minVal,right.minVal)); // m,m / M,M / m,M / M,m  -> m : for min, M : for Max 
            myAns.maxVal = Math.max(myAns.maxVal, Evaluate(ch,left.maxVal,right.maxVal));
        }

        return dp[si][ei] = myAns;
    }

    public  static void minMaxEvaluation(){
        int[] num = {1,2,3,4,5};
        char[] operator ={'+','*','+','*'};
        int n = num.length;
        pair[][] dp = new pair[n][n];


        pair ans = minMaxEvaluation(num,operator,0,n-1,dp);
        System.out.println("minVal : "  + ans.minVal + ", maxVal: " + ans.maxVal);
    }

    public int maxCoins(int[] nums,int si,int ei ,int[][] dp) {
        if(dp[si][ei] != -1) return dp[si][ei];

        int lVal = (si == 0) ? 1 : nums[si-1];
        int rVal = (ei == nums.length - 1) ? 1 : nums[ei + 1];


        
        int myAns = 0;
        for(int cut = si; cut <= ei; cut++){
            int leftAns = (cut == si) ? 0 : maxCoins(nums,si,cut-1,dp);
            int rightAns = (cut == ei) ? 0 : maxCoins(nums,cut+1,ei,dp);

            myAns = Math.max(myAns, leftAns + lVal * nums[cut] * rVal + rightAns);
        }

        return dp[si][ei] = myAns;
    }


    public int maxCoins(int[] nums) {
        int n = nums.length;
        if(n == 0) return 0;
        
        int[][] dp = new int[n][n];
        for(int[] d: dp)Arrays.fill(d,-1);
        
        return maxCoins(nums,0,n-1,dp);   
    }

    //https://www.geeksforgeeks.org/optimal-binary-search-tree-dp-24/

    // only for memoization
    public static int OBST(int[] keys,int[] freq,int si,int ei,int level,int[][][] dp){
        if(dp[si][ei][level] != -1) return dp[si][ei][level];

        int minCost = (int) 1e9;
        for(int cut = si; cut<=ei;cut++){
            int leftTree = (cut == si) ? 0 : OBST(keys,freq, si, cut-1 ,level + 1,dp);
            int rightTree = (cut == ei) ? 0 : OBST(keys,freq, cut + 1, ei ,level + 1,dp);

            minCost = Math.min(minCost, leftTree + freq[cut] * level  + rightTree);
        }

        return dp[si][ei][level] = minCost;
    }

    public static int OBST_01(int[] keys,int[] freq,int si,int ei,int[] psum,int[][] dp){
        if(dp[si][ei] != -1) return dp[si][ei];

        int minCost = (int) 1e9;
        for(int cut = si; cut<=ei;cut++){
            int leftTree = (cut == si) ? 0 : OBST(keys,freq, si, cut-1 ,psum,dp);
            int rightTree = (cut == ei) ? 0 : OBST(keys,freq, cut + 1, ei ,psum,dp);

            minCost = Math.min(minCost, leftTree + (psum[ei] - (si == 0 ? 0 :psum[si-1]))  + rightTree);
        }
        
        return dp[si][ei] = minCost;
    }

    public static int OBST_02(int[] keys,int[] freq,int si,int ei,int[][] dp){
        if(dp[si][ei] != -1) return dp[si][ei];

        int minCost = (int) 1e9;
        int sum = 0;
        for(int cut = si; cut<=ei;cut++){
            int leftTree = (cut == si) ? 0 : OBST(keys,freq, si, cut-1 ,dp);
            int rightTree = (cut == ei) ? 0 : OBST(keys,freq, cut + 1, ei ,dp);
            sum += arr[cut];
            minCost = Math.min(minCost, leftTree + rightTree);
        }
        
        return dp[si][ei] = minCost + sum;
    }

    public static int OBST_02_DP(int[] keys,int[] freq,int SI,int EI,int[][] dp){
        int n = keys.length;
        for(int gap = 0; gap < n ;gap++){
            for(int si=0,ei = gap;ei < n;si++,ei++){
                int minCost = (int) 1e9;
                int sum = 0;
                for(int cut = si; cut<=ei;cut++){
                    int leftTree = (cut == si) ? 0 : dp[si][cut-1];
                    int rightTree = (cut == ei) ? 0 : dp[cut+1][ei];
                    sum += arr[cut];
                    minCost = Math.min(minCost, leftTree + rightTree);
                }
                
                dp[si][ei] = minCost + sum;
            }
        }
        return dp[SI][EI];
    }

    public static void OBST(){
        int[] keys={10, 12, 20};
        int[] freq ={34, 8, 50};
        int n = keys.length;
        int[] psum = new int[n];
        int prev = 0;
        for(int i=0;i<n;i++){
            psum[i] = prev + freq[i];
            prev = psum[i];
        }

        int[][][] dp = new int[n][n][n+1];
        for(int[][] D:dp) for(int[] d:D) Arrays.fill(d,-1);
        System.out.println(OBST(keys,freq,0,n-1,1,dp));
    }

    //1039
    public int minScoreTriangulation(int[] A,int si,int ei,int[][] dp) {
        if(si + 1 == ei){
            return dp[si][ei] = 0;
        }
        if(dp[si][ei] != 0) return dp[si][ei];
        
        int minAns = (int)1e9;
        for(int cut = si + 1; cut < ei;cut++){
            int leftPoly = minScoreTriangulation(A,si,cut,dp);
            int rightPoly = minScoreTriangulation(A,cut,ei,dp);
            
            minAns = Math.min(minAns, leftPoly + A[si] * A[cut] * A[ei] + rightPoly);
        }

        return dp[si][ei] = minAns;
    }
    
    public int minScoreTriangulation(int[] A) {
        int n = A.length;
        int[][] dp = new int[n][n];
        return minScoreTriangulation(A,0,n-1,dp); 
    }

    //https://practice.geeksforgeeks.org/problems/boolean-parenthesization/0#
    public static void main (String[] args) throws IOException 
    {
        Scanner scn = new Scanner(new BufferedReader(new InputStreamReader((System.in))));
        //  Scanner scn = new Scanner( System.in);
        int t = scn.nextInt();
        while(t-->0){
            int n = scn.nextInt();
            scn.nextLine();
            String str = scn.nextLine();
            
            int N = str.length();
            pair_[][] dp = new pair_[N][N];
            System.out.println(booleanParen(str,0,N - 1,dp).TCount % mod);
        }
    
    }
    
        public static class pair_{
       int TCount = 0;
       int FCount = 0;

       pair_(int T,int F){
           this.TCount = T;
           this.FCount = F;
       }
   }
   
   static int mod = 1003;
   public static void EvaluateBooleanAns(pair_ leftAns, pair_ rightAns,char oper,pair_ ans){
        int totalWays =  ( (leftAns.TCount % mod + leftAns.FCount % mod) % mod * (rightAns.TCount % mod + rightAns.FCount % mod) % mod ) % mod;
        if(oper == '|'){
           
           int fcount = (leftAns.FCount % mod * rightAns.FCount % mod) % mod;
           ans.TCount += (totalWays % mod - fcount  % mod + mod) % mod;
           ans.FCount += fcount;

       }else if(oper == '&'){
           
           int tcount = (leftAns.TCount % mod * rightAns.TCount % mod) % mod;
           ans.TCount += tcount;
           ans.FCount += (totalWays % mod - tcount  % mod + mod) % mod;
      
       }else{
           
           int tcount = ( (leftAns.TCount % mod * rightAns.FCount % mod) % mod + (leftAns.FCount % mod * rightAns.TCount % mod) % mod) % mod;
           ans.TCount += tcount;
           ans.FCount += (totalWays % mod - tcount  % mod + mod) % mod;
       
       }


   }

   public static pair_ booleanParen(String str,int si,int ei,pair_[][] dp){
       if(si == ei){
           int t = str.charAt(si) == 'T' ? 1 : 0;
           int f = str.charAt(si) == 'F' ? 1 : 0;
           pair_ base = new pair_(t,f);
           return dp[si][ei] = base;
       }

       if(dp[si][ei] != null) return dp[si][ei];

       pair_ ans = new pair_(0,0);
       for(int cut = si + 1;cut < ei; cut+=2){
           pair_ leftAns = booleanParen(str,si,cut-1,dp);
           pair_ rightAns = booleanParen(str,cut+1,ei,dp);

           char oper = str.charAt(cut);
           EvaluateBooleanAns(leftAns,rightAns,oper,ans);
       }

       return dp[si][ei] = ans;
   }


   //leetcode 132
   public int minCut(String str,int si,int[] dp,boolean[][] isPalindrome){
    if(si == str.length() || isPalindrome[si][str.length() - 1]){
        return dp[si] = 0;
    }
    
    if(dp[si] != -1) return dp[si];
    
    int ans  = (int)1e8;
    for(int cut = si;cut < str.length();cut++){
        if(isPalindrome[si][cut]){
            int MinCutCount =  minCut(str,cut+1,dp,isPalindrome);
            ans = Math.min(ans,MinCutCount + 1);
        }
    }
    
    return dp[si] = ans;
}


public int minCut(String str) {
    if(str.length() <= 1) return 0;
    int n = str.length();
    
    boolean[][] isPalindrome = new boolean[n][n];
    for(int gap = 0;gap<n;gap++){
        for(int i = 0,j = gap;j < n;i++,j++){
            if(gap == 0) isPalindrome[i][j] = true;
            else if(gap == 1) isPalindrome[i][j] = str.charAt(i) == str.charAt(j);
            else isPalindrome[i][j] = isPalindrome[i +1 ][j - 1] && (str.charAt(i) == str.charAt(j));
        }
    }
    
    int[] dp = new int[n + 1];
    Arrays.fill(dp,-1);
    return minCut(str,0,dp,isPalindrome);
}

public int palindromePartition(int si,int ei,int k,int[][] dp,int[][] pdp){
    if(k == 0) return dp[k][ei] = 0;
    if(k == 1) return dp[k][ei] = pdp[si][ei];
    if(ei - si + 1 <= k) return dp[k][ei] = (ei-si+1 < k) ? (int)1e8 : 0;
    
    if(dp[k][ei] != -1) return dp[k][ei];
    
    int min_ = (int)1e8; 
    for(int cut = si; cut < ei;cut++){
        int recAns = palindromePartition(si,cut,k-1,dp,pdp);
        
        min_ = Math.min(min_, pdp[cut + 1][ei] + recAns);
    }
    
    return dp[k][ei] = min_;
}


public int palindromePartition(String str, int k) {
    if(str.length() == 0 || k == 0 || str.length() <= k) return 0;
    int n = str.length();
    int[][] pdp = new int[n][n];
    
    for(int gap = 1;gap<n;gap++){
        for(int i=0,j=gap;j<n;i++,j++){
            pdp[i][j] = pdp[i+1][j-1];
            if(str.charAt(i) != str.charAt(j)) pdp[i][j]++;
        }
    }
    
    int[][] dp = new int[k + 1][n + 1];
    for(int[] d: dp) Arrays.fill(d,-1);
    
    return palindromePartition(0,n-1,k,dp,pdp);
    
}


    public static void main(String[] args){
        // MCM();
        // minMaxEvaluation();
        OBST();
    }
}

import java.util.*;
import java.lang.*;
import java.io.*;
    
public class questions{
	public static void main (String[] args)
	 {
	      Scanner scn=new Scanner(System.in);
	      int t=scn.nextInt();
	      while(t-->0){
	          int[] arr=new int[scn.nextInt()];
	          for(int i=0;i<arr.length;i++) arr[i]=scn.nextInt();
	          System.out.println(LBS(arr));
	      }
	 }
	 
	 
    // Left to Right
    public static int LIS_LR(int[] arr,int[] dp){
        int max_=0;
        for(int i=0;i<arr.length;i++){
            dp[i] = 1;
            for(int j = i-1;j>=0;j--){
                if(arr[j] < arr[i]){
                    dp[i]=Math.max(dp[i],dp[j]+1);
                }
            }
            max_=Math.max(max_,dp[i]);
        }
        return max_;
    }

    // Right to Left
    public static int LIS_RL(int[] arr,int[] dp){
            int max_=0;
            for(int i = arr.length-1; i>=0 ; i--){
                dp[i] = 1;
                for(int j = i+1;j < arr.length;j++){
                    if(arr[j] < arr[i]){
                        dp[i]=Math.max(dp[i],dp[j]+1);
                    }
                }
                max_=Math.max(max_,dp[i]);
            }
            return max_;
    }

    // https://www.geeksforgeeks.org/longest-bitonic-subsequence-dp-15/
    public static int LBS(int[] arr){
        int n=arr.length;
        int[] LIS=new int[n];
        int[] LDS=new int[n];

        LIS_LR(arr,LIS);
        LIS_RL(arr,LDS);

        int maxLen=0;
        for(int i=0;i<n;i++){
            int len=LIS[i]+LDS[i]-1;
            maxLen=Math.max(maxLen,len);
        }

        return maxLen;
    }


    //Maximum Sum Bitonic subsequnece
    // Left to Right
    public static int LIS_LR(int[] arr,int[] dp){
        int max_=0;
        for(int i=0;i<arr.length;i++){
            dp[i] = arr[i];
            for(int j = i-1;j>=0;j--){
                if(arr[j] < arr[i]){
                    dp[i]=Math.max(dp[i],dp[j]+arr[i]);
                }
            }
            max_=Math.max(max_,dp[i]);
        }
        return max_;
    }

    // Right to Left
    public static int LIS_RL(int[] arr,int[] dp){
            int max_=0;
            for(int i = arr.length-1; i>=0 ; i--){
                dp[i] = arr[i];
                for(int j = i+1;j < arr.length;j++){
                    if(arr[j] < arr[i]){
                        dp[i]=Math.max(dp[i],dp[j]+arr[i]);
                    }
                }
                max_=Math.max(max_,dp[i]);
            }
            return max_;
    }

    public static int LBS(int[] arr){
        int n=arr.length;
        int[] LIS=new int[n];
        int[] LDS=new int[n];

        LIS_LR(arr,LIS);
        LIS_RL(arr,LDS);

        int maxLen=0;
        for(int i=0;i<n;i++){
            int len=LIS[i]+LDS[i]-arr[i];
            maxLen=Math.max(maxLen,len);
        }

        return maxLen;
    }

    // Leetcode 416
    public boolean canPartition(int[] nums) {
        
        int sum=0;
        for(int ele: nums){
            sum+=ele;
        }
        
        if(sum%2!=0) return false;
        
        boolean[][] dp=new boolean[nums.length+1][sum/2+1];
        return targetSum_01_DP(nums,sum/2,nums.length,dp);
    }
    
     public static boolean targetSum_01_DP(int[] coins,int tar,int n,boolean[][] dp){
        int N=n;
        int Tar=tar;
 
        for(n=0;n<=N;n++){
            for(tar=0;tar<=Tar;tar++){
                if(tar == 0 || n == 0){
                    dp[n][tar] = (tar==0)?true:false;
                    continue;
                }
                
                dp[n][tar]=false;
                if(tar-coins[n-1]>=0)
                   dp[n][tar]=dp[n][tar] || dp[n-1][tar-coins[n-1]];
                dp[n][tar]=dp[n][tar] || dp[n-1][tar];
            }
        }

        return dp[N][Tar];
    }

public static int findTargetSumWays_memo(int[] nums, int n, int sum, int tar,int[][] dp){
    if (n == 0)
        return dp[n][sum] = ((tar == (0 + sum)) ? 1 : 0);

    if (dp[n][sum] != -1)
        return dp[n][sum];

    int include = findTargetSumWays_memo(nums, n - 1, sum - nums[n - 1], tar,dp);  // positive call
    int exclude = findTargetSumWays_memo(nums, n - 1, sum + nums[n - 1], tar,dp); // nrgative call

    return dp[n][sum] = include + exclude;
}


public static int findTargetSumWays(vector<int> &nums, int s)
{
    if (nums.length == 0)
        return 0;

    int n = nums.length;
    int sum = 0;

    for (int i : nums)
        sum += i;
    if (s > sum || s < -sum)
        return 0;

    int[][] dp=new int[n+1][2*sum+1];
    for(int[] a: dp) Arrays.fill(a,-1);

    return findTargetSumWays_memo(nums, n, sum, s+sum,dp);
  }

  //leetcode 174

  int n,m;
    
  public int calculateMinimumHP(int sr,int sc,int[][] dungeon,int[][] dp) {
      if(sr==n-1 && sc==m-1){
          return dp[sr][sc]=Math.max(1, 1 - dungeon[sr][sc]);
      }    
      if(dp[sr][sc]!=0) return dp[sr][sc];
      
      int min=(int)1e8;
      if(sr+1 < n)
          min=Math.min(min,calculateMinimumHP(sr+1,sc,dungeon,dp));
      
      if(sc+1 < m)
          min=Math.min(min,calculateMinimumHP(sr,sc+1,dungeon,dp));
      
      min -=dungeon[sr][sc];
      return dp[sr][sc]=Math.max(min,1);
          
  }
   
  public int calculateMinimumHP(int[][] dungeon) {
      n=dungeon.length;
      m=dungeon[0].length;
      int[][] dp=new int[n][m];
      return calculateMinimumHP(0,0,dungeon,dp);
      
  }
}

import java.util.LinkedList;
import java.util.Arrays;

public class l001 {

   



    

    public static int mazePath_Rec_01(int sr, int sc, int er, int ec, int[][] dp) {
        if (sr == er && sc == ec) {
            return dp[sr][sc] = 1;
        }

        if (dp[sr][sc] != 0)
            return dp[sr][sc];

        int count = 0;
        if (sr + 1 <= er)
            count += mazePath_Rec_01(sr + 1, sc, er, ec, dp);
        if (sc + 1 <= ec)
            count += mazePath_Rec_01(sr, sc + 1, er, ec, dp);
        if (sr + 1 <= er && sc + 1 <= ec)
            count += mazePath_Rec_01(sr + 1, sc + 1, er, ec, dp);

        return dp[sr][sc] = count;
    }

    public static int mazePath_Rec_02(int sr, int sc, int er, int ec, int[][] dp) {
        if (sr == er && sc == ec) {
            return dp[sr][sc] = 1;
        }

        if (dp[sr][sc] != 0)
            return dp[sr][sc];

        int count = 0;
        for (int jump = 1; sr + jump <= er; jump++)
            count += mazePath_Rec_02(sr + jump, sc, er, ec, dp);
        for (int jump = 1; sc + jump <= ec; jump++)
            count += mazePath_Rec_02(sr, sc + jump, er, ec, dp);
        for (int jump = 1; sr + jump <= er && sc + jump <= ec; jump++)
            count += mazePath_Rec_02(sr + jump, sc + jump, er, ec, dp);

        return dp[sr][sc] = count;
    }

    public static int mazePath_DP_01(int sr, int sc, int er, int ec, int[][] dp) {
        for (sr = er; sr >= 0; sr--) {
            for (sc = ec; sc >= 0; sc--) {
                if (sr == er && sc == ec) {
                    dp[sr][sc] = 1;
                    continue;
                }

                int count = 0;
                if (sr + 1 <= er)
                    count += dp[sr + 1][sc];// mazePath_Rec_01(sr + 1, sc, er, ec, dp);
                if (sc + 1 <= ec)
                    count += dp[sr][sc + 1];// mazePath_Rec_01(sr, sc + 1, er, ec, dp);
                if (sr + 1 <= er && sc + 1 <= ec)
                    count += dp[sr + 1][sc + 1];// mazePath_Rec_01(sr + 1, sc + 1, er, ec, dp);

                dp[sr][sc] = count;
            }
        }

        return dp[0][0];
    }

    public static int mazePath_DP_02(int sr, int sc, int er, int ec, int[][] dp) {
        for (sr = er; sr >= 0; sr--) {
            for (sc = ec; sc >= 0; sc--) {
                if (sr == er && sc == ec) {
                    dp[sr][sc] = 1;
                    continue;
                }

                int count = 0;
                for (int jump = 1; sr + jump <= er; jump++)
                    count += dp[sr + jump][sc];
                for (int jump = 1; sc + jump <= ec; jump++)
                    count += dp[sr][sc + jump];
                for (int jump = 1; sr + jump <= er && sc + jump <= ec; jump++)
                    count += dp[sr + jump][sc + jump];

                dp[sr][sc] = count;
            }
        }

        return dp[0][0];
    }

    // to_Be_done------------------------------------------->62_and_63_of_leetcode.

    public static int boardPath_Rec_01(int si, int ei, int[] dp) {
        if (si == ei) {
            return dp[si] = 1;
        }

        if (dp[si] != 0)
            return dp[si];

        int count = 0;
        for (int dice = 1; dice <= 6 && si + dice <= ei; dice++) {
            count += boardPath_Rec_01(si + dice, ei, dp);
        }

        return dp[si] = count;
    }

    public static int boardPath_DP_01(int si, int ei, int[] dp) {

        for (si = ei; si >= 0; si--) {
            if (si == ei) {
                dp[si] = 1;
                continue;
            }

            int count = 0;
            for (int dice = 1; dice <= 6 && si + dice <= ei; dice++) {
                count += dp[si + dice];// boardPath_Rec_01(si + dice, ei, dp);
            }

            dp[si] = count;
        }

        return dp[0];
    }

    public static int boardPath_opti(int ei) {
        LinkedList<Integer> ll = new LinkedList<>();

        for (int si = 0; si <= ei; si++) {
            if (si < 2) {
                ll.addFirst(1);
                continue;
            }

            if (ll.size() <= 6)
                ll.addFirst(2 * ll.getFirst());
            else {
                ll.addFirst(2 * ll.getFirst() - ll.getLast());
                ll.removeLast();
            }
        }

        return ll.getFirst();
    }

    public static int boardPath_DP_02(int si, int ei, int[] moves, int[] dp) {
        for (si = ei; si >= 0; si--) {
            if (si == ei) {
                dp[si] = 1;
                continue;
            }

            int count = 0;
            for (int i = 0; i < moves.length; i++) {
                if (si + moves[i] <= ei)
                    count += dp[si + moves[i]];// boardPath_Rec_01(si + moves[i], ei, dp);
            }

            dp[si] = count;
        }

        return dp[0];
    }

    // https://practice.geeksforgeeks.org/problems/gold-mine-problem/0

    public static int goldmineProblem(int[][] grid, int sr, int sc, int[][] dp) {
        if (sc == grid[0].length - 1)
            return grid[sr][sc];
        if (dp[sr][sc] != 0)
            return dp[sr][sc];

        int[][] dirA = { { 0, 1 }, { -1, 1 }, { 1, 1 } };
        int maxCoin = 0; // max coin collected by nbrs.
        for (int d = 0; d < 3; d++) {
            int r = sr + dirA[d][0];
            int c = sc + dirA[d][1];
            if (r >= 0 && c >= 0 && r < grid.length && c < grid[0].length) {
                maxCoin = Math.max(maxCoin, goldmineProblem(grid, r, c, dp));
            }
        }

        return dp[sr][sc] = maxCoin + grid[sr][sc];
    }

    public static int goldmineProblem_DP(int[][] grid, int sr, int sc, int[][] dp) {

        int[][] dirA = { { 0, 1 }, { -1, 1 }, { 1, 1 } };
        for (sc = grid[0].length - 1; sc >= 0; sc--) {
            for (sr = grid.length - 1; sr >= 0; sr--) {
                if (sc == grid[0].length - 1) {
                    dp[sr][sc] = grid[sr][sc];
                    continue;
                }

                int maxCoin = 0; // max coin collected by nbrs.
                for (int d = 0; d < 3; d++) {
                    int r = sr + dirA[d][0];
                    int c = sc + dirA[d][1];
                    if (r >= 0 && c >= 0 && r < grid.length && c < grid[0].length) {
                        maxCoin = Math.max(maxCoin, dp[r][c]);
                    }
                }

                dp[sr][sc] = maxCoin + grid[sr][sc];
            }
        }
        int MaxCoins = 0;
        for (int i = 0; i < grid.length; i++) {
            MaxCoins = Math.max(MaxCoins, dp[i][0]);
        }
        return MaxCoins;
    }

    public static int goldmineProblem(int[][] grid) {
        int[][] dp = new int[grid.length][grid[0].length];

        int MaxCoins = 0;
        for (int i = 0; i < grid.length; i++) {
            MaxCoins = Math.max(MaxCoins, goldmineProblem(grid, i, 0, dp));
        }

        return MaxCoins;
    }

    // Leetcode 64

    public static int minPathSum(int[][] grid) {
        int[][] dp = new int[grid.length][grid[0].length];

        for (int sr = grid.length - 1; sr >= 0; sr--) {
            for (int sc = grid[0].length - 1; sc >= 0; sc--) {
                if (sr == grid.length - 1 && sc == grid[0].length - 1) {
                    dp[sr][sc] = grid[sr][sc];
                    continue;
                }

                int minCoins = (int) 1e8;
                if (sc + 1 < grid[0].length)
                    minCoins = Math.min(minCoins, dp[sr][sc + 1]);
                if (sr + 1 < grid.length)
                    minCoins = Math.min(minCoins, dp[sr + 1][sc]);

                dp[sr][sc] = minCoins + grid[sr][sc];
            }
        }

        return dp[0][0];
    }

    // Leetcode 70.

    public static int climbStairs(int n, int[] dp) {
        if (n <= 1)
            return dp[n] = 1;
        if (dp[n] != 0)
            return dp[n];

        return dp[n] = climbStairs(n - 1, dp) + climbStairs(n - 2, dp);
    }

    public static int climbStairs(int n) {

        int[] dp = new int[n + 1];
        return climbStairs(n, dp);
    }

    public static int minCostClimbingStairs(int[] cost, int n, int[] dp) {
        if (n <= 1)
            return dp[n] = cost[n];
        if (dp[n] != 0)
            return dp[n];

        int minCost = Math.min(minCostClimbingStairs(cost, n - 1, dp), minCostClimbingStairs(cost, n - 2, dp));

        return dp[n] = minCost + (n == cost.length ? 0 : cost[n]);
    }

    public static int minCostClimbingStairs_Opti(int[] cost) {
        int a = cost[0];
        int b = cost[1];

        for (int i = 2; i < cost.length; i++) {
            int ans = Math.min(a, b) + cost[i];
            a = b;
            b = ans;
        }
        return Math.min(a, b);
    }

    public static int minCostClimbingStairs(int[] cost) {
        int[] dp = new int[cost.length + 1];

        return minCostClimbingStairs(cost, cost.length, dp);
    }

    // https://practice.geeksforgeeks.org/problems/friends-pairing-problem/0

    public static long friendsPairingProblem(int n, long[] dp) {
        if (n <= 1)
            return dp[n] = 1;
        if (dp[n] != 0)
            return dp[n];

        long single = friendsPairingProblem(n - 1, dp) % mod;
        long pairUp = friendsPairingProblem(n - 2, dp) % mod * (n - 1) % mod;

        return dp[n] = (single + pairUp) % mod;
    }

    public static long friendsPairingProblem_DP(int n, long[] dp) {
        int N = n;
        for (n = 0; n <= N; n++) {
            if (n <= 1) {
                dp[n] = 1;
                continue;
            }

            long single = dp[n - 1] % mod;// friendsPairingProblem(n - 1, dp);
            long pairUp = dp[n - 2] % mod * (n - 1) % mod;// friendsPairingProblem(n - 2, dp) * (n - 1);

            dp[n] = single + pairUp;
        }

        return dp[N] % mod;
    }

    public static int friendsPairingProblem_Opti(int n) {
        int single = 1;
        int pairUp = 1;

        int ans = 0;
        for (int i = 2; i <= n; i++) {
            ans = single + pairUp * (i - 1);

            pairUp = single;
            single = ans;
        }

        return ans;
    }

    public static void friendsPairingProblem() {
        // int n = scn.nextInt();
        int n = 5;
        long[] dp = new long[n + 1];
        long ans = friendsPairingProblem(n, dp);

        System.out.println(ans);
    }

    // https://www.geeksforgeeks.org/count-number-of-ways-to-partition-a-set-into-k-subsets/

    public static int count_of_ways(int n, int k, int[][] dp) {
        if (k == n || k == 1)
            return dp[k][n] = 1;

        if (dp[k][n] != -1)
            return dp[k][n];

        int ownGroup = count_of_ways(n - 1, k - 1, dp);
        int partOfOtherGroup = count_of_ways(n - 1, k, dp) * k;

        return dp[k][n] = ownGroup + partOfOtherGroup;
    }

    public static int count_of_ways_DP(int n, int k, int[][] dp) {
        int K = k;
        int N = n;
        for (k = 1; k <= K; k++) {
            for (n = k; n <= N; n++) {
                if (k == n || k == 1) {
                    dp[k][n] = 1;
                    continue;
                }

                int ownGroup = dp[k - 1][n - 1]; // count_of_ways(n - 1, k - 1, dp);
                int partOfOtherGroup = dp[k][n - 1] * k;// count_of_ways(n - 1, k, dp) * k;

                dp[k][n] = ownGroup + partOfOtherGroup;
            }
        }

        return dp[K][N];
    }

    public static void count_of_ways(int n, int k) {
        int[][] dp = new int[k + 1][n + 1];
        for (int[] d : dp)
            Arrays.fill(d, -1);

        // System.out.println(count_of_ways(n, k, dp));
        System.out.println(count_of_ways_DP(n, k, dp));

        display2D(dp);
    }
    // String_set=========================================================================================

    // Leetcode 005,647.
    public static int[][] longestPalindromeSubstring(String str) {
        int n = str.length();
        int[][] dp = new int[n][n];

        int maxLen = 0;
        int count = 0;
        int si = 0, ei = 0;
        for (int gap = 0; gap < n; gap++) {
            for (int i = 0, j = gap; j < n; j++, i++) {
                if (gap == 0)
                    dp[i][j] = 1;
                else if (gap == 1 && str.charAt(i) == str.charAt(j))
                    dp[i][j] = 2;
                else if (str.charAt(i) == str.charAt(j) && dp[i + 1][j - 1] > 0) // if dp[i][j] > 0 means it is a
                                                                                 // palindrome.
                    dp[i][j] = dp[i + 1][j - 1] + 2;

                if (dp[i][j] > maxLen) {
                    maxLen = dp[i][j];
                    si = i;
                    ei = j;
                }
                count += (dp[i][j] > 0) ? 1 : 0;
            }
        }

        System.out.println("maxLen: " + maxLen + " and Count of total Palindromes: " + count);
        System.out.println(str.substring(si, ei + 1));

        return dp;
    }

    // Leetcode 516
    public static int longestPlaindromeSubsequence(String str, int i, int j, int[][] dp) {
        if (i > j)
            return dp[i][j] = 0;
        if (i == j)
            return dp[i][j] = 1;
        if (dp[i][j] != 0)
            return dp[i][j];
        int maxLen = 0;
        if (str.charAt(i) == str.charAt(j))
            maxLen = longestPlaindromeSubsequence(str, i + 1, j - 1, dp) + 2;
        else
            maxLen = Math.max(longestPlaindromeSubsequence(str, i + 1, j, dp),
                    longestPlaindromeSubsequence(str, i, j - 1, dp));

        return dp[i][j] = maxLen;
    }

    public static class pair {
        String str = "";
        int len = 0;

        pair(String str, int len) {
            this.str = str;
            this.len = len;
        }
    }

    public static pair longestPlaindromeSubsequence_02(String str, int i, int j, pair[][] dp) {
        if (i > j)
            return dp[i][j] = new pair("", 0);
        if (i == j)
            return dp[i][j] = new pair(str.charAt(i) + "", 1);

        if (dp[i][j] != null)
            return dp[i][j];

        pair maxPair = new pair("", 0);
        if (str.charAt(i) == str.charAt(j)) {
            pair recAns = longestPlaindromeSubsequence_02(str, i + 1, j - 1, dp);
            maxPair.str = str.charAt(i) + recAns.str + str.charAt(j);
            maxPair.len = recAns.len + 2;
        } else {
            pair recAns1 = longestPlaindromeSubsequence_02(str, i + 1, j, dp);
            pair recAns2 = longestPlaindromeSubsequence_02(str, i, j - 1, dp);

            if (recAns1.len > recAns2.len) {
                maxPair.len = recAns1.len;
                maxPair.str = recAns1.str;
            } else {
                maxPair.len = recAns2.len;
                maxPair.str = recAns2.str;
            }
        }

        return dp[i][j] = maxPair;

    }

    public static int longestPlaindromeSubsequence_DP(String str, int i, int j, int[][] dp) {
        int n = str.length();

        String[][] sdp = new String[n][n];
        for (String[] d : sdp)
            Arrays.fill(d, "");

        for (int gap = 0; gap < n; gap++) {
            for (i = 0, j = gap; j < n; j++, i++) {
                if (i == j) {
                    dp[i][j] = 1;
                    continue;
                }

                if (str.charAt(i) == str.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                    sdp[i][j] = str.charAt(i) + sdp[i + 1][j - 1] + str.charAt(j);

                } else if (dp[i + 1][j] > dp[i][j - 1]) {
                    dp[i][j] = dp[i + 1][j];
                    sdp[i][j] = sdp[i + 1][j];
                } else {
                    dp[i][j] = dp[i][j - 1];
                    sdp[i][j] = sdp[i][j - 1];
                }

            }
        }

        System.out.println(sdp[0][n - 1] + " @ " + dp[0][n - 1]);
        return dp[0][n - 1];
    }

    // Leetcode 115
    // https://practice.geeksforgeeks.org/problems/find-number-of-times-a-string-occurs-as-a-subsequence/0

    public static int numDistinct_(String s, String t, int n, int m, int[][] dp) {
        if (n < m)
            return dp[n][m] = 0;
        if (m == 0)
            return dp[n][m] = 1;

        if (dp[n][m] != -1)
            return dp[n][m];

        if (s.charAt(n - 1) == t.charAt(m - 1)) {
            return dp[n][m] = numDistinct_(s, t, n - 1, m - 1, dp) + numDistinct_(s, t, n - 1, m, dp);
        } else
            return dp[n][m] = numDistinct_(s, t, n - 1, m, dp);

    }

    public static int numDistinct_DP_(String s, String t, int n, int m, int[][] dp) {
        int N = n, M = m;
        for (n = 0; n <= N; n++) {
            for (m = 0; m <= M; m++) {
                if (n < m) {
                    dp[n][m] = 0;
                    continue;
                }
                if (m == 0) {
                    dp[n][m] = 1;
                    continue;
                }

                if (s.charAt(n - 1) == t.charAt(m - 1)) {
                    dp[n][m] = dp[n - 1][m - 1] + dp[n - 1][m];
                } else
                    dp[n][m] = dp[n - 1][m];
            }
        }
        return dp[N][M];
    }

    public static int numDistinct(String s, String t) {
        int n = s.length();
        int m = t.length();
        int[][] dp = new int[n + 1][m + 1];
        for (int[] d : dp)
            Arrays.fill(d, -1);
        // int ans = numDistinct_(s, t, n, m, dp);
        int ans = numDistinct_DP_(s, t, n, m, dp);

        for (int[] d : dp) {
            for (int ele : d) {
                System.out.print(ele + " ");
            }
            System.out.println();
        }
        return ans;
    }

    // Leetcode 1143
    public static int LCSubseq(String str1, int n, String str2, int m, int[][] dp) {
        if (n == 0 || m == 0)
            return 0;
        if (dp[n][m] != -1)
            return dp[n][m];
        if (str1.charAt(n - 1) == str2.charAt(m - 1))
            return dp[n][m] = LCSubseq(str1, n - 1, str2, m - 1, dp) + 1;
        else
            return dp[n][m] = Math.max(LCSubseq(str1, n - 1, str2, m, dp), LCSubseq(str1, n, str2, m - 1, dp));
    }

    public static int LCSubseq_DP(String str1, int n, String str2, int m, int[][] dp) {

        int N = n, M = m;
        for (n = 0; n <= N; n++) {
            for (m = 0; m <= M; m++) {
                if (n == 0 || m == 0) {
                    dp[n][m] = 0;
                    continue;
                }
                if (str1.charAt(n - 1) == str2.charAt(m - 1))
                    dp[n][m] = dp[n - 1][m - 1] + 1;
                else
                    dp[n][m] = Math.max(dp[n - 1][m], dp[n][m - 1]);

            }
        }
        return dp[N][M];
    }

    public static int longestCommonSubsequence(String text1, String text2) {
        int[][] dp = new int[text1.length() + 1][text2.length() + 1];
        for (int[] d : dp)
            Arrays.fill(d, -1);

        // int ans = LCSubseq(text1, text1.length(), text2, text2.length(), dp);
        int ans = LCSubseq_DP(text1, text1.length(), text2, text2.length(), dp);

        display2D(dp);
        return ans;
    }

    // Leetcode 1035
    public static int maxUncrossedLines(int[] A, int[] B) {
        int N = A.length;
        int M = B.length;

        int[][] dp = new int[N + 1][M + 1];

        for (int n = 0; n <= N; n++) {
            for (int m = 0; m <= M; m++) {

                if (n == 0 || m == 0) {
                    dp[n][m] = 0;
                    continue;
                }
                if (A[n - 1] == B[m - 1])
                    dp[n][m] = dp[n - 1][m - 1] + 1;
                else
                    dp[n][m] = Math.max(dp[n - 1][m], dp[n][m - 1]);
            }

        }

        return dp[N][M];
    }

    public static int editDistance(String word1, String word2, int n, int m, int[][] dp) {
        if (n == 0 || m == 0) {
            return dp[n][m] = ((n == 0) ? m : n);
        }

        if (dp[n][m] != -1)
            return dp[n][m];

        if (word1.charAt(n - 1) == word2.charAt(m - 1))
            return dp[n][m] = editDistance(word1, word2, n - 1, m - 1, dp);
        else {
            int insert_ = editDistance(word1, word2, n, m - 1, dp);
            int delete_ = editDistance(word1, word2, n - 1, m, dp);
            int replace_ = editDistance(word1, word2, n - 1, m - 1, dp);

            return dp[n][m] = Math.min(Math.min(insert_, replace_), delete_) + 1;
        }
    }

    public static int editDistance_DP(String word1, String word2, int n, int m, int[][] dp) {
        int N = n;
        int M = m;
        for (n = 0; n <= N; n++) {
            for (m = 0; m <= M; m++) {

                if (n == 0 || m == 0) {
                    dp[n][m] = n == 0 ? m : n;
                    continue;
                }
                if (word1.charAt(n - 1) == word2.charAt(m - 1))
                    dp[n][m] = dp[n - 1][m - 1];
                else
                    dp[n][m] = Math.min(Math.min(dp[n - 1][m], dp[n][m - 1]), dp[n - 1][m - 1]) + 1;
            }

        }

        return dp[N][M];
    }

    public static int minDistance(String word1, String word2) {
        int[][] dp = new int[word1.length() + 1][word2.length() + 1];
        for (int[] d : dp)
            Arrays.fill(d, -1);
        return editDistance(word1, word2, word1.length(), word2.length(), dp);
    }

    public static int countPalindromicSubsequence(String str, int i, int j, int[][] dp) {
        if (i > j)
            return dp[i][j] = 0;

        if (i == j)
            return dp[i][j] = 1;

        if (dp[i][j] != 0)
            return dp[i][j];

        int a = countPalindromicSubsequence(str, i + 1, j - 1, dp);
        int b = countPalindromicSubsequence(str, i, j - 1, dp);
        int c = countPalindromicSubsequence(str, i + 1, j, dp);

        if (str.charAt(i) == str.charAt(j))
            return dp[i][j] = (a + 1) + (b + c - a);
        else
            return dp[i][j] = b + c - a;
    }

    public static int countPalindromicSubsequence_DP(String str, int i, int j, int[][] dp) {

        for (int gap = 0; gap < str.length(); gap++) {
            for (i = 0, j = gap; j < str.length(); i++, j++) {
                if (i == j) {
                    dp[i][j] = 1;
                    continue;
                }
                int a = dp[i + 1][j - 1];// countPalindromicSubsequence(str, i + 1, j - 1, dp);
                int b = dp[i][j - 1];// countPalindromicSubsequence(str, i, j - 1, dp);
                int c = dp[i + 1][j];// countPalindromicSubsequence(str, i + 1, j, dp);

                if (str.charAt(i) == str.charAt(j))
                    dp[i][j] = (a + 1) + (b + c - a);
                else
                    dp[i][j] = b + c - a;
            }
        }

        return dp[0][str.length() - 1];
    }

    // leetcode 940
    public static int distinctSubseqII(String str) {
        int mod = (int) 1e9 + 7;
        str = '$' + str;
        int n = str.length();
        long[] dp = new long[n];

        int[] loc = new int[26];

        dp[0] = 1;
        for (int i = 1; i < n; i++) {
            dp[i] = (2 * dp[i - 1]% mod)% mod ;
            int idx = str.charAt(i) - 'a';

            if (loc[idx] != -1) {
                dp[i] = (dp[i] % mod - dp[loc[idx] - 1] % mod + mod)% mod;
            }

            loc[idx] = i;
        }

        return (int) dp[n - 1]%mod;

    }

    public static void countPalindromicSubsequence(String str) {
        int n = str.length();
        int[][] dp = new int[n][n];
        // System.out.println(countPalindromicSubsequence(str, 0, n - 1, dp));
        System.out.println(countPalindromicSubsequence_DP(str, 0, n - 1, dp));

        display2D(dp);
    }
    
    //LIS_series.=======================================================================================
     
    public static int LIS_Rec(int[] arr,int ei,int[] dp){        
        if(dp[ei]!=0) return dp[ei];
        
        int maxLen=1;
        for(int i=ei;i >=0 ;i--){
            
            if(arr[i] < arr[ei]){
               int len = LIS_Rec(arr,i,dp);
               maxLen = Math.max(maxLen,len+1);
            }
        }

        return dp[ei] = maxLen;
    }

    public static int LIS_Rec(int[] arr){
        if(arr.length == 0) return 0;

        int n=arr.length;
        int[] dp=new int[n];
        int max_=0;
        for(int i=n-1;i>=0;i--){
           max_=Math.max(LIS_Rec(arr,i,dp),max_);
        }

        return max_;
    }

    // Left to Right
    public static int LIS_LR(int[] arr,int[] dp){
        int max_=0;
        for(int i=0;i<arr.length;i++){
            dp[i] = 1;
            for(int j = i-1;j>=0;j--){
                if(arr[j] < arr[i]){
                    dp[i]=Math.max(dp[i],dp[j]+1);
                }
            }
            max_=Math.max(max_,dp[i]);
        }
        return max_;
    }

    // Right to Left
    public static int LIS_RL(int[] arr,int[] dp){
            int max_=0;
            for(int i = arr.length-1; i>=0 ; i--){
                dp[i] = 1;
                for(int j = i+1;j < arr.length;j++){
                    if(arr[j] < arr[i]){
                        dp[i]=Math.max(dp[i],dp[j]+1);
                    }
                }
                max_=Math.max(max_,dp[i]);
            }
            return max_;
    }

    // https://www.geeksforgeeks.org/longest-bitonic-subsequence-dp-15/
    public static int LBS(int[] arr){
        int n=arr.length;
        int[] LIS=new int[n];
        int[] LDS=new int[n];

        LIS_LR(arr,LIS);
        LIS_RL(arr,LDS);

        int maxLen=0;
        for(int i=0;i<n;i++){
            int len=LIS[i]+LDS[i]-1;
            maxLen=Math.max(maxLen,len);
        }

        return maxLen;
    }

    //Minimum deletion to make a array in sorted order.
    public static int minDeletion(int[] arr){
        int n = arr.length;
        int[] dp = new int[n];
        
        int max_=0;
        for(int i=0;i<arr.length;i++){
            dp[i] = 1;
            for(int j = i-1;j>=0;j--){
                if(arr[j] <= arr[i]){
                    dp[i]=Math.max(dp[i],dp[j]+1);
                }
            }
            max_=Math.max(max_,dp[i]);
        }

        return n - max_;
    }

    //----------------> // question for you : //https://practice.geeksforgeeks.org/problems/maximum-sum-bitonic-subsequence/0


    //Leetcode 354.
    public static int maxEnvelopes(int[][] arr) {
        if(arr.length==0) return 0;
        
        // sort(arr.begin(),arr.end(),[](vector<int>& a,vector<int>& b){
        //     return a[0] < b[0];
        // });

        Arrays.sort(arr,(a,b)->{
            if(a[0]==b[0]) return b[1]-a[1];   // other - this
            return a[0]-b[0]; // this - other, increasing order.
        });
        
        int n=arr.length;
        int[] dp=new int[n];
        int max_=0;

        for(int i=0;i<n;i++){
            dp[i]=1;
            for(int j=i-1;j>=0;j--){
                if(arr[j][1] < arr[i][1]){
                    dp[i]=Math.max(dp[i],dp[j]+1);
                }
            }
            max_=Math.max(max_,dp[i]);
        }

        return max_;
    }

    //for you-----------> Leetcode 1027, 1235
    // https://www.geeksforgeeks.org/dynamic-programming-building-bridges/
    
    public int findNumberOfLIS(int[] arr) {
        
        int n=arr.length;
        int[] dp=new int[n];
        int[] count=new int[n];

        int maxLen=0;
        int maxCount=0;

        for(int i=0;i<n;i++){
            dp[i] = 1;
            count[i] = 1;
            
            for(int j=i-1;j>=0;j--){
                if(arr[i]>arr[j]){
                    if(dp[j] + 1 > dp[i]){
                        dp[i] = dp[j] + 1;
                        count[i] = count[j];
                    }else if(dp[i] == dp[j] + 1) 
                        count[i] +=count[j];
                }
            }


            if(dp[i]>maxLen){
                maxLen=dp[i];
                maxCount=count[i];
            }else if(dp[i]==maxLen){
                maxCount+=count[i];
            }
        }
        return maxCount;
    }

    // TargetSet.=========================================================================================

    public static int coinChangePermutation(int[] arr,int tar,int[] dp){
        if(tar==0){
            return dp[tar] = 1;
        }

        if(dp[tar]!=0) return dp[tar];

        int count=0;
        for(int ele: arr){
            if(tar-ele>=0){
              count+=coinChangePermutation(arr,tar-ele,dp);
            }
        }

        return dp[tar] = count;
    }

    public static int coinChangePermutation_DP(int[] arr,int tar,int[] dp){
        int Tar=tar;
        dp[0] = 1;
        for( tar=0;tar<=Tar;tar++)
            for(int ele: arr){
                if(tar-ele>=0){
                  dp[tar]+=dp[tar-ele];
                }
            }
            return dp[Tar];
    }

    public static int coinChangeCombination(int[] arr,int tar,int idx){
        if(tar==0){
            return 1;
        }

        int count=0;
        for(int i=idx;i<arr.length;i++){
            if(tar-arr[idx]>=0){
              count+=coinChangeCombination(arr,tar-arr[idx],i);
            }
        }

        return count;
    }

    public static int coinChangeCombination_DP(int[] arr,int tar,int[] dp){
        int Tar=tar;
        dp[0]=1;
        for(int ele: arr)
            for( tar=ele;tar<=Tar;tar++)
                if(tar-ele>=0)
                  dp[tar]+=dp[tar-ele];
        return dp[Tar];
    }

    public int coinChange_(int[] coins, int amount,int[] dp) {
        if(amount==0){
            return dp[amount] = 0;
        }

        if(dp[amount]!=0) return dp[amount];
        
        int minCoins=(int)1e8;
        for(int ele: coins){
            if(amount - ele >= 0){
                minCoins = Math.min(minCoins,coinChange_(coins,amount-ele,dp)+1);
               
            }
        }

        return dp[amount]=minCoins;
    }

    public int coinChange_02(int[] coins, int amount,int[] dp) {
        Arrays.fill(dp,100000000);
        int Amount = amount;
        dp[0] = 0;
        for(int ele: coins){
            for(amount = ele;amount<=Amount;amount++){
               if(dp[amount-ele] + 1 < dp[amount]){
                   dp[amount]=dp[amount-ele] + 1;
               }
            }
        }
      return dp[Amount];
    }

    
    public int coinChange(int[] coins, int amount) {
        int[] dp=new int[amount+1];
        int ans = coinChange_(coins,amount,dp);
        
        
        return ans!=(int)1e8?ans:-1;
    }

    // Geeks fot you: https://www.geeksforgeeks.org/find-number-of-solutions-of-a-linear-equation-of-n-variables/

    public static int targetSum(int[] coins,int tar,int vidx,int[][] dp){
        if(tar==0 || vidx == coins.length){
            return dp[vidx][tar] = (tar==0)?1:0;
        }

        if(dp[vidx][tar]!=-1) return dp[vidx][tar];

        int count=0;
        if(tar-coins[vidx]>=0)
           count+=targetSum(coins,tar-coins[vidx],vidx+1,dp);
        count+=targetSum(coins,tar,vidx+1,dp);

        return dp[vidx][tar]=count;
    }

    public static int targetSum_01(int[] coins,int tar,int n,int[][] dp){
        if(tar==0 || n == 0){
            return dp[n][tar] = (tar==0)?1:0;
        }

        if(dp[n][tar]!=-1) return dp[n][tar];

        int count=0;
        if(tar-coins[n-1]>=0)
           count+=targetSum_01(coins,tar-coins[n-1],n-1,dp);
        count+=targetSum_01(coins,tar,n-1,dp);

        return dp[n][tar]=count;
    }

    public static int targetSum_01_DP(int[] coins,int tar,int n,int[][] dp){
        int N=n;
        int Tar=tar;

        for(n=0;n<=N;n++){
            for(tar=0;tar<=Tar;tar++){
                if(tar == 0 || n == 0){
                    dp[n][tar] = (tar==0)?1:0;
                    continue;
                }
                
                dp[n][tar]=0;
                if(tar-coins[n-1]>=0)
                   dp[n][tar]+=dp[n-1][tar-coins[n-1]];
                dp[n][tar]+=dp[n-1][tar];
            }
        }

        return dp[N][Tar];
    }

    public static void targetSum_01_BE(int[] coins,int tar,int n,int[][] dp,String str){
        if(tar==0 || n == 0){
            System.out.println(str);
            return;
        }

        
        if(tar-coins[n-1]>=0 && dp[n-1][tar-coins[n-1]]!=0)
           targetSum_01_BE(coins,tar-coins[n-1],n-1,dp,coins[n-1] + " " +str);
        
        if(dp[n-1][tar]!=0)
           targetSum_01_BE(coins,tar,n-1,dp,str);
    }

    public static void targetSum(){
        //  int[] coins={1,2,3,4,5,6,7,8};
         int[] coins={2,1,3,5,6};
         int tar = 10;

         int[][] dp=new int[coins.length + 1][tar+1];
         for(int[] d:dp) Arrays.fill(d,-1);

        //  System.out.println(targetSum(coins,tar,0,dp));
        //  System.out.println(targetSum_01(coins,tar,coins.length,dp));
         System.out.println(targetSum_01_DP(coins,tar,coins.length,dp));
         targetSum_01_BE(coins,6,coins.length,dp,"");
         display2D(dp);
    }

    public static int knapSack_01_Rec(int[] weight,int[] value,int cap,int n,int[][] dp){
        if(cap==0 || n == 0){
            return dp[n][cap] = 0;
        }

        if(dp[n][cap]!=-1) return dp[n][cap];

        int maxProfit = 0;
        if(cap-weight[n-1]>=0)
           maxProfit = Math.max(maxProfit,knapSack_01_Rec(weight,value,cap-weight[n-1],n-1,dp) + value[n-1]);
        
        maxProfit = Math.max(maxProfit,knapSack_01_Rec(weight,value,cap,n-1,dp));

        return dp[n][cap]=maxProfit;
    }

    public static int knapSack_01_DP(int[] weight,int[] value,int cap,int n,int[][] dp){
        
        int N=n;
        int CAP=cap;
        for(n=0;n<=N;n++){
            for(cap=0;cap<=CAP;cap++){
                if(cap==0 || n == 0){
                    dp[n][cap] = 0;
                    continue;
                }
        
                int maxProfit = 0;
                if(cap-weight[n-1]>=0)
                   maxProfit = Math.max(maxProfit,dp[n-1][cap - weight[n-1]] + value[n-1]);
                
                maxProfit = Math.max(maxProfit,dp[n-1][cap]);
        
                dp[n][cap]=maxProfit;
            }

        }
    }

    public static int knapSack_01_DP(int[] weight,int[] value,int cap){
        int n=weight.length;
        int[] dp=new int[cap+1];

        for(int i=0;i<n;i++){
            for(int c = weight[i];c<=cap;c++){
                dp[c]=Math.max(dp[c],dp[c-weight[i]]+value[i]);
            }
        }

        return dp[cap];
    }



    public static void knapSack_01(){
        int weight[]={1,2,3};
        int value[]={6,10,12};
        int we=5;
        
        int[][] dp=new int[weight.length+1][we+1];

    }



    // ===================================================================================================

    public static void targetSet(){
        // int[] coins={2,3,5,7};
        // int tar=10;
        // int[] dp=new int[tar+1];
        // System.out.println(coinChangePermutation(coins,tar,dp));

        // display(dp);
        targetSum();
    }

    public static void String_set() {
        // String str = "effbccbade";
        // int n = str.length();
        // int[][] dp = new int[n][n];

        // longestPalindromeSubstring("effbccbad");
        // System.out.println(longestPlaindromeSubsequence(str, 0, n - 1, dp));
        // System.out.println(longestPlaindromeSubsequence_DP(str, 0, n - 1, dp));

        // pair[][] dp = new pair[n][n];
        // pair ans = longestPlaindromeSubsequence_02(str, 0, n - 1, dp);
        // System.out.println(ans.str + "@" + ans.len);

        // longestCommonSubsequence("AGGTAB", "GXTXAYB");
        countPalindromicSubsequence("baccbab");

        // display2D(dp);
    }

    public static void pathSet() {
        // int n = 4, m = 4;
        // int[][] dp = new int[n][m];

        // System.out.println(mazePath_Rec_01(0, 0, n - 1, m - 1, dp));
        // System.out.println(mazePath_DP_01(0, 0, n - 1, m - 1, dp));

        // System.out.println(mazePath_Rec_02(0, 0, n - 1, m - 1, dp));
        // System.out.println(mazePath_DP_02(0, 0, n - 1, m - 1, dp));

        // int n = 10;
        // int[] dp = new int[n + 1];
        // int[] moves = { 2, 4, 1, 5 };
        // System.out.println(boardPath_Rec_01(0, n, dp));
        // System.out.println(boardPath_DP_01(0, n, dp));
        // System.out.println(boardPath_opti(n));

        // System.out.println(boardPath_DP_02(0, n, moves, dp));

        count_of_ways(5, 3);

        // display(dp);
        // display2D(dp);
    }





}

import java.util.*;
import java.lang.*;
import java.io.*;

class frinePairingProblem {
    static int mod = (int) 1e9 + 7;

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int t = scn.nextInt();
        while (t-- > 0) {
            int n = scn.nextInt();
            friendsPairingProblem(n);
        }

    }

    public static long friendsPairingProblem(int n, long[] dp) {
        if (n <= 1)
            return dp[n] = 1;
        if (dp[n] != 0)
            return dp[n];

        long single = friendsPairingProblem(n - 1, dp) % mod;
        long pairUp = friendsPairingProblem(n - 2, dp) % mod * (n - 1) % mod;

        return dp[n] = (single + pairUp) % mod;
    }

    public static long friendsPairingProblem_DP(int n, long[] dp) {
        int N = n;
        for (n = 0; n <= N; n++) {
            if (n <= 1) {
                dp[n] = 1;
                continue;
            }

            long single = dp[n - 1] % mod;// friendsPairingProblem(n - 1, dp);
            long pairUp = dp[n - 2] % mod * (n - 1) % mod;// friendsPairingProblem(n - 2, dp) * (n - 1);

            dp[n] = single + pairUp;
        }

        return dp[N] % mod;
    }

    public static int friendsPairingProblem_Opti(int n) {
        int single = 1;
        int pairUp = 1;

        int ans = 0;
        for (int i = 2; i <= n; i++) {
            ans = single + pairUp * (i - 1);

            single = pairUp;
            pairUp = ans;
        }

        return ans;
    }

    public static void friendsPairingProblem(int n) {
        // int n=scn.nextInt();
        long[] dp = new long[n + 1];
        long ans = friendsPairingProblem(n, dp);

        System.out.println(ans);
    }

}

public class l002_CutType{

    public static void display(int[] dp) {
        for (int ele : dp)
            System.out.print(ele + " ");
        System.out.println();
    }

    public static void display2D(int[][] dp) {
        for (int[] ar : dp) {
            display(ar);
        }
        System.out.println();
    }


    public static int MCM_Rec(int[] arr,int si,int ei,int[][] dp){
        if(si+1 == ei) return dp[si][ei] = 0;
        if(dp[si][ei] != 0) return dp[si][ei]; 

        int myAns=(int)1e8;
        for(int cut=si+1;cut<ei;cut++){
            int leftRes=MCM_Rec(arr,si,cut,dp);
            int rightRes=MCM_Rec(arr,cut,ei,dp);
            
            int recRes = leftRes +  arr[si]*arr[cut]*arr[ei]  + rightRes;
            if(recRes<myAns) myAns = recRes; 
        }

        return dp[si][ei] = myAns;
    }

    public static int MCM_DP(int[] arr,int si,int ei,int[][] dp){

        for(int gap = 1; gap < arr.length;gap++){
            for(si=0,ei=gap;ei<arr.length;si++,ei++){
                if(si+1 == ei) {
                    dp[si][ei] = 0;
                    continue;
                }
                int myAns=(int)1e8;
                for(int cut=si+1;cut<ei;cut++){
                    int leftRes = dp[si][cut];//MCM_Rec(arr,si,cut,dp);
                    int rightRes = dp[cut][ei];//MCM_Rec(arr,cut,ei,dp);
            
                    int recRes = leftRes +  arr[si] * arr[cut] * arr[ei]  + rightRes;
                    if(recRes<myAns) myAns = recRes; 
                }

            dp[si][ei] = myAns;
            }
        }
    
        return dp[0][arr.length-1];
    }

    public static int MCM_Rec_02(int[] arr,int si,int ei,int[][] dp,String[][] sdp){
        if(si+1 == ei) {
            sdp[si][ei] = ((char)(si+'A')+"");
            return dp[si][ei] = 0;
        }
            
        if(dp[si][ei] != 0) return dp[si][ei]; 

        dp[si][ei]=(int)1e8;
        for(int cut=si+1;cut<ei;cut++){
            int leftRes=MCM_Rec_02(arr,si,cut,dp,sdp);
            int rightRes=MCM_Rec_02(arr,cut,ei,dp,sdp);
            
            int recRes = leftRes +  arr[si] * arr[cut] * arr[ei]  + rightRes;
            if(recRes < dp[si][ei]) {
                sdp[si][ei] = "(" + sdp[si][cut] + sdp[cut][ei] + ")";
                dp[si][ei] = recRes; 
            }
        }
        return dp[si][ei];
    }

    public static void MCM(){
        int[] arr={10, 20, 30, 40, 30};
        int n=arr.length;

        int[][] dp=new int[n][n];
        String[][] sdp=new String[n][n];
        
        // System.out.println(MCM_Rec(arr,0,n-1,dp));
        // System.out.println(MCM_DP(arr,0,n-1,dp));
        System.out.println(MCM_Rec_02(arr,0,n-1,dp,sdp));
        
        System.out.println(sdp[0][n-1]);
        display2D(dp);
        for(String[] s: sdp){
            for(String e:s) System.out.print(e+" ");
            System.out.println();
        }
    }

    //OBST.======================================================

    public static int summation(int si,int ei,int[] freq){
        int sum=0;
        while(si<=ei) sum+=freq[si++];
        return sum;
    }

    public static int OBST_Rec(int[] freq,int si,int ei,int[][] dp,int[] prefixSum){
        if(dp[si][ei] != 0) return dp[si][ei]; 

        int myAns=(int)1e8;
        for(int cut=si;cut<=ei;cut++){
            int leftRes = cut == si ? 0 : OBST_Rec(freq,si,cut,dp,prefixSum);
            int rightRes = cut == ei ? 0 : OBST_Rec(freq,cut,ei,dp,prefixSum);
            
            int recRes = leftRes +  (prefixSum[ei]-(si==0?0:prefixSum[si])) + rightRes;
            if(recRes<myAns) myAns = recRes; 
        }

        return dp[si][ei] = myAns;
    }

    public static int maxCoins(int[] nums,int si,int ei,int[][] dp) {
        if(dp[si][ei]!=0) return dp[si][ei];

        int lval = si == 0 ? 1 : nums[si-1];
        int rval = ei == nums.length -1 ? 1 : nums[ei+1];

        int maxAns = 0;
        for(int cut = si;cut<=ei;cut++){
            int leftRes = cut == si ? 0 : maxCoins(nums,si,cut - 1,dp);
            int rightRes = cut == ei ? 0 : maxCoins(nums,cut + 1, ei, dp); 

            int myAns = leftRes + lval * nums[cut] * rval + rightRes;
            maxAns = Math.max(maxAns, myAns);
        }

        return dp[si][ei] = maxAns;
    }

    public static int maxCoinsDP(int[] nums,int si,int ei,int[][] dp) {
        
        for(int gap = 1; gap < nums.length;gap++){
            for(si=0,ei=gap;ei<nums.length;si++,ei++){
                int lval = si == 0 ? 1 : nums[si-1];
                int rval = ei == nums.length - 1 ? 1 : nums[ei+1];

                int maxAns = 0;
                for(int cut = si;cut<=ei;cut++){
                    int leftRes = cut == si ? 0 : dp[si][cut-1];//maxCoins(nums,si,cut - 1,dp);
                    int rightRes = cut == ei ? 0 : dp[cut+1][ei];//maxCoins(nums,cut + 1, ei, dp); 

                    int myAns = leftRes + lval * nums[cut] * rval + rightRes;
                    maxAns = Math.max(maxAns, myAns);
                }

            dp[si][ei] = maxAns;
            }
        }

        return dp[0][nums.length-1];
        
    }

    public static int evaluateExpression(int a,int b,char oper){
        if(oper=='+') return a+b;
        else return a*b;

    }

    public static class pair{
        int min=(int)1e8;
        int max= (int) -1e8;
       
        String minStr="";
        String maxStr="";
        pair(int min,int max,String minStr,String maxStr){
            this.min = min;
            this.max = max;

            this.minStr = minStr;
            this.maxStr = maxStr;
        }

        pair(){
        }

        @Override
        public String toString(){
           return "(" + min + ", " + max  + ")";
        }
    }

    public static pair minMaxEval(String str,int si,int ei,pair[][] dp){
        if(si==ei){
            char ch = str.charAt(si);
            int val = ch-'0';
            return new pair(val,val, val+"",val+"");
        }

        if(dp[si][ei] != null) return dp[si][ei];
        
        pair maxAns = new pair();
        for(int cut = si + 1;cut < ei; cut+=2){
            pair leftRes = minMaxEval(str, si, cut-1, dp);
            pair rightRes = minMaxEval(str, cut + 1, ei, dp); 

            int minVal = evaluateExpression(leftRes.min,rightRes.min,str.charAt(cut));
            int maxVal = evaluateExpression(leftRes.max,rightRes.max,str.charAt(cut));
            
            if(minVal < maxAns.min){
                maxAns.min=minVal;
                maxAns.minStr = "("+leftRes.minStr + str.charAt(cut) + rightRes.minStr + ")";
            }

            if(maxVal > maxAns.max){
                maxAns.max=maxVal;
                maxAns.maxStr = "("+leftRes.maxStr + str.charAt(cut) + rightRes.maxStr + ")";
            }
        }

        return dp[si][ei] = maxAns;

    }

    public static int minPlaindromicCut(String str,int si,int ei,int[][] dp,boolean[][] palindromicSubstring){
        if(palindromicSubstring[si][ei]) return 0;
        if(dp[si][ei] != -1) return dp[si][ei];
        int minCut=(int)1e8;
        
        for(int cut = si; cut < ei; cut++){
            int leftRes = minPlaindromicCut(str,si,cut,dp,palindromicSubstring);
            int rightRes = minPlaindromicCut(str,cut+1,ei,dp,palindromicSubstring);
            
            int myAns= leftRes + 1 + rightRes;
            minCut = Math.min(minCut, myAns);
        }

        return dp[si][ei]=minCut;
    }

    public static int minPlaindromicCut_bestMethod(String str,int si,int ei,int[] dp,boolean[][] palindromicSubstring){
        if(palindromicSubstring[si][ei]) return 0;
        if(dp[si] != -1) return dp[si];
        
        int minCut=(int)1e8;
        for(int cut = si; cut < ei; cut++){
            if(palindromicSubstring[si][cut]){
              minCut = Math.min(minCut,minPlaindromicCut_bestMethod(str,cut+1,ei,dp,palindromicSubstring)+1);
            }            
        }

        return dp[si]=minCut;
    }

    public static int minCut(String str) {
		int n = str.length();
		int[][] dp=new int[n][n];
		boolean[][] isPalindrome=new boolean[n][n];

		for(int[] d: dp) Arrays.fill(d,-1);

		for (int gap = 0; gap < n; gap++) {
			for (int si = 0, ei = gap; ei < n; si++, ei++) {
				if (gap == 0) isPalindrome[si][ei] = true;
				else if (str.charAt(si) == str.charAt(ei) && gap == 1) isPalindrome[si][ei] = true;
				else isPalindrome[si][ei] = str.charAt(si) == str.charAt(ei) && isPalindrome[si + 1][ei - 1];
			}
		}

		return minPlaindromicCut(str,0,n-1,dp,isPalindrome);
    }

    public static int minTriangulation(int[] arr,int si,int ei,int[][] dp){
        if(ei - si < 2) return 0;
        if(dp[si][ei]!=0) return dp[si][ei];

        int minAns = (int)1e8;
        for(int cut = si + 1; cut < ei; cut++){
            int leftAns = minTriangulation(arr,si,cut,dp);
            int rightAns = minTriangulation(arr,cut,ei,dp);

            int myAns = leftAns + arr[si]*arr[cut]*arr[ei]  + rightAns;
            minAns=Math.min(minAns,myAns); 
        }

        return dp[si][ei] = minAns;
    }

    
    public int minScoreTriangulation(int[] A) {
        int n = A.length;
        int[][] dp = new int[n][n];
        return minTriangulation(A,0,n-1,dp); 
    }
    

    public static void minMaxEval(){
        String str="1+2*3+4*5";
        int n=str.length();
        pair[][] dp=new pair[n][n];

        pair ans=minMaxEval(str,0,n-1,dp);
        System.out.println(ans.minStr + " -> "+ans.min);
        System.out.println(ans.maxStr + " -> "+ans.max);
        

        // for(pair[] d : dp){
        //     for(pair e : d){
        //         System.out.print(e + " ");
        //     }
        //     System.out.println();
        // }
    }

    public static int maxCoins(int[] nums) {
        int n=nums.length; if(n==0) return 0;
        int[][] dp =new int[n][n];
        
        return maxCoins(nums,0,n-1,dp);   
    }

    public static void OBST(){
        int[] keys={10,12,20};
        int[] freq={34, 8, 50};
    }

    public static void main(String[] args){
        // MCM();
        minMaxEval();
       
    }






}



public class l001{

    

    

    // Leetcode 70 .=============================================================
    public int climbStairs(int n,int[] dp) {
        if(n<=1){
            return dp[n] = 1;
        }

        if(dp[n]!=0) return dp[n];
        
        int ans = climbStairs(n-1,dp) + climbStairs(n-2,dp);
        
        return dp[n] = ans;
    }

    public int climbStairs_DP(int N,int[] dp) {
        for(int n = 0;n<=N;n++){
            if(n<=1){
                dp[n] = 1;
                continue;
            }
    
            int ans = dp[n-1] + dp[n-2];//climbStairs(n-1,dp) + climbStairs(n-2,dp);
            
            dp[n] = ans;
        }
        return dp[N];
    }

    public  int climbStairs(int n) {
        int[] dp = new int[n + 1];
        // return climbStairs(n, dp);
        return climbStairs_DP(n,dp);
    }

    //Leetcode 746.==============================================================
    public int minCostClimbingStairs(int[] cost,int n,int[] dp){
        if(n<=1){
            return dp[n] = cost[n];
        }

        if(dp[n]!=0) return dp[n];

        int ans = Math.min(minCostClimbingStairs(cost,n-1,dp),minCostClimbingStairs(cost,n-2,dp));

        return dp[n] = ans + (n!=cost.length?cost[n]:0);
    }

    public int minCostClimbingStairs_DP(int[] cost,int N, int[] dp){
        for(int n = 0 ;n<=N;n++){
            if(n<=1){
                dp[n] = cost[n];
                continue;
            }
    
            int ans = Math.min(dp[n-1],dp[n-2]);
    
            dp[n] = ans + (n != cost.length ? cost[n] : 0);
        }
        return dp[N];
    }

    public  int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] dp = new int[cost.length + 1];
        int ans = minCostClimbingStairs(cost,n,dp);
        // int ans = minCostClimbingStairs_DP(cost,n,dp);
        return ans;
    }

    //Geeks : https://www.geeksforgeeks.org/friends-pairing-problem/ ============

    public static int friendsPairing(int n,int[] dp){
        if(n<=1){
            return dp[n] = 1;
        }

        if(dp[n]!=0) return dp[n];

        int single = friendsPairing(n-1,dp);
        int pairUp = friendsPairing(n-2,dp) * ( n - 1 );

        return dp[n] = single + pairUp;
    }

    public static int friendsPairing_DP(int N,int[] dp){
        for(int n = 0; n<=N;n++){
            if(n<=1){
               dp[n] = 1;
               continue;
            }
    
            int single = dp[n-1];//friendsPairing(n-1,dp);
            int pairUp = dp[n-2] * (n-1);//friendsPairing(n-2,dp) * ( n - 1 );
    
            dp[n] = single + pairUp;
        }
        return dp[N];
    }

    public static int friendsPairing_Opti(int N){
        int a = 1;
        int b = 1;
        for(int n = 2; n<=N;n++){
            int sum = b + a * (n-1); 
            a = b;
            b = sum; 
        }
        return b;
    }

    //Path Set.==============================================================
    public static int mazePath_HVD(int sr,int sc,int er,int ec,int[][] dp,int[][] dir){
        if(sr==er && sc==ec){
            return dp[sr][sc]=1;
        }
        if(dp[sr][sc]!=0) return dp[sr][sc];

        int count = 0;
        for(int d=0;d<dir.length;d++){
            int r = sr + dir[d][0];
            int c = sc + dir[d][1];

            if(r <= er && c <= ec)
              count += mazePath_HVD(r,c,er,ec,dp,dir); 
        }

        return dp[sr][sc] = count;
    }


    public static int mazePath_HVD_Multi(int sr,int sc,int er,int ec,int[][] dp,int[][] dir){
        if(sr==er && sc==ec){
            return dp[sr][sc]=1;
        }
        if(dp[sr][sc]!=0) return dp[sr][sc];

        int count = 0;
        for(int d=0;d<dir.length;d++){
            for(int rad = 1;rad <= dp.length;rad++){
               int r = sr + rad*dir[d][0];
               int c = sc + rad*dir[d][1];

               if(r <= er && c <= ec)
                count += mazePath_HVD_Multi(r,c,er,ec,dp,dir);
               else break;
            } 
        }

        return dp[sr][sc] = count;
    }

    public static int mazePath_HVD_DP(int sr,int sc,int er,int ec,int[][] dp,int[][] dir){
        for(sr = er;sr>=0;sr--){
            for(sc = ec;sc>=0;sc--){
                if(sr==er && sc==ec){
                    dp[sr][sc]=1;
                    continue;
                }

                
                int count = 0;
                for(int d=0;d<dir.length;d++){
                    int r = sr + dir[d][0];
                    int c = sc + dir[d][1];
        
                    if(r <= er && c <= ec)
                      count += dp[r][c]; 
                }
        
                dp[sr][sc] = count;
            }
        }

        return dp[0][0];
    }


    public static int mazePath_HVD_Multi_DP(int sr,int sc,int er,int ec,int[][] dp,int[][] dir){
        for(sr = er;sr>=0;sr--){
            for(sc = ec;sc>=0;sc--){
                
                if(sr==er && sc==ec){
                    dp[sr][sc]=1;
                    continue;
                }

                int count = 0;
                for(int d=0;d<dir.length;d++){
                    for(int rad = 1;rad <= dp.length;rad++){
                       int r = sr + rad*dir[d][0];
                       int c = sc + rad*dir[d][1];
        
                       if(r <= er && c <= ec)
                        count += dp[r][c];
                       else break;
                    } 
                }
        
                dp[sr][sc] = count;
            }
        }

        return dp[0][0];
    }

    public static int boardPath(int si,int ei,int[] dp){
        if(si==ei){
            return dp[si] = 1;
        }
        if(dp[si]!=0) return dp[si];

        int count=0;
        for(int dice = 1;dice <= 6 && si+dice<=ei ; dice++){
            count+=boardPath(si+dice,ei,dp);
        }

        return dp[si] = count;
    }

    public static int boardPath_DP(int si,int ei,int[] dp){ 
        for(si = ei; si>=0;si--){
            if(si==ei){
                dp[si] = 1;
                continue;
            }

            int count=0;
            for(int dice = 1;dice <= 6 && si+dice<=ei ; dice++){
                count += dp[si+dice];
            }
    
            dp[si] = count;
        }

        return dp[0];
    }

    public static int boardPath_Opti(int si,int ei){ 
        LinkedList<Integer> ll = new LinkedList<>();
        for(si = ei; si>=0;si--){
            if(si >= ei-1){
                ll.addFirst(1);
                continue;
            }

            if(ll.size()<=6) 
              ll.addFirst(2*ll.getFirst());
            else
               ll.addFirst((2 * ll.getFirst()) - ll.removeLast());
        }

        return ll.getFirst();
    }

    public static int boardPath_Opti2(int ei){ 
        int[] ans = {1,1,2,4,8,16,32};
        int idx = 6;
        if(ei<=6) return ans[ei];

        for(int i=7;i<=ei;i++){
            int val = 2*ans[idx];
            idx = (idx+1) % 7;
            val -= ans[idx];

            ans[idx] = val;     
        }

        return ans[idx];
    }

    //Leetcode 64
    public int minPathSum(int[][] grid,int sr,int sc,int[][] dp) {
        if(sr == grid.length - 1 && sc == grid[0].length - 1){
            return dp[sr][sc] = grid[sr][sc];
        }

        if(dp[sr][sc]!=0) return dp[sr][sc];
        
        int minAns = (int) 1e9;
        if(sr + 1 < grid.length) minAns = Math.min(minAns, minPathSum(grid,sr+1,sc,dp));
        if(sc + 1 < grid[0].length) minAns = Math.min(minAns, minPathSum(grid,sr,sc+1,dp));

        return dp[sr][sc]=minAns;
    }

    
    public int minPathSum_DP(int[][] grid,int sr,int sc,int[][] dp) {
        for(sr = grid.length-1;sr>=0;sr--){
            for(sc = grid[0].length-1;sc>=0;sc--){
                if(sr == grid.length - 1 && sc == grid[0].length - 1){
                    dp[sr][sc] = grid[sr][sc];
                }
                
                int minAns = (int) 1e9;
                if(sr + 1 < grid.length) minAns = Math.min(minAns, dp[sr+1][sc]);
                if(sc + 1 < grid[0].length) minAns = Math.min(minAns,dp[sr][sc+1]);
        
                dp[sr][sc]=minAns;
            }
        }

        return dp[0][0];
    }

    public int minPathSum(int[][] grid) {
        int[][] dp = new int[grid.length][grid[0].length];
        int ans= minPathSum(grid,0,0,dp);         
        return ans;
    }

    public static int goldMine(int[][] grid,int sr,int sc,int[][] dp,int[][] dir){
        if(sc==grid[0].length-1){
            return dp[sr][sc] = grid[sr][sc];
        }

        if(dp[sr][sc]!=0) return dp[sr][sc];

        int maxAns = 0;
        for(int d=0;d<dir.length;d++){
            int r = sr + dir[d][0];
            int c = sc + dir[d][1];
            
            if(r>=0 && c>=0 && r< grid.length && c<grid[0].length)
              maxAns = Math.max(maxAns,goldMine(grid,r,c,dp,dir));
        }

        return dp[sr][sc] = maxAns + grid[sr][sc];
    }

    public static void goldMineP_DP(int[][] grid,int sr,int sc,int[][] dp,int[][] dir){
        for(sr = grid.length-1;sr>=0;sr--){
            for(sc = grid[0].length-1;sc>=0;sc--){
                if(sr == grid.length-1 && sc == grid[0].length-1){
                     dp[sr][sc] = grid[sr][sc];
                     continue;
                }
        
                int maxAns = 0;
                for(int d=0;d<dir.length;d++){
                    int r = sr + dir[d][0];
                    int c = sc + dir[d][1];
                    
                    if(r>=0 && c>=0 && r< grid.length && c<grid[0].length)
                      maxAns = Math.max(maxAns,dp[r][c]);
                }
        
                dp[sr][sc] = maxAns + grid[sr][sc];
            }
        }

        int maxRes =0;
        for(int i=0;i<grid.length;i++)
          maxRes = Math.max(maxRes, dp[i][0]);

        System.out.println(maxRes);
        
    }



    public static void goldMine(int[][] grid){
        int n = grid.length;
        int m = grid[0].length;
        int[][] dp = new int[n][m]; 
        
        int maxAns = 0;
        int[][] dir = {{-1,1},{0,1},{1,1}};

        for(int i=0;i<n;i++)
          maxAns = Math.max(maxAns, goldMine(grid,i,0,dp,dir));
        
        System.out.println(maxAns);
    }

    // https://www.geeksforgeeks.org/count-number-of-ways-to-partition-a-set-into-k-subsets/

    public static int countWays(int n,int k,int[][] dp){
        // if(n < k) return 0; 
        if(n==k || k==1){
            return dp[n][k] = 1;
        }

        if(dp[n][k] != -1) return dp[n][k];

        int ownSet = countWays(n-1,k-1,dp);
        int partOfSet = countWays(n-1,k,dp) * k;

        return dp[n][k] = ownSet + partOfSet;
    }

    
    public static int countWays_DP(int N,int K,int[][] dp){ 
        for(int n = 1;n<=N;n++){
            for(int k=1;k<=K;k++){
                if(n<k){
                    dp[n][k] =0;
                    break;
                }

                if(n==k || k==1){
                    dp[n][k] = 1;
                    continue;
                }
        
                int ownSet = dp[n-1][k-1];//countWays(n-1,k-1,dp);
                int partOfSet = dp[n-1][k]* k;
        
                dp[n][k] = ownSet + partOfSet;
            }
        }

        return dp[N][K];
    }

    //https://practice.geeksforgeeks.org/problems/mobile-numeric-keypad/0

    public static void mazePath(){
        // int n = 3;
        // int m = 3;

        // int[][] dp = new int[n][m];
        // int[][] dir = {{1,0},{0,1},{1,1}};

        // System.out.println(mazePath_HVD(0,0,n-1,m-1,dp,dir));
        // System.out.println(mazePath_HVD_Multi(0,0,n-1,m-1,dp,dir));

        // System.out.println(mazePath_HVD_DP(0,0,n-1,m-1,dp,dir));
        // System.out.println(mazePath_HVD_Multi_DP(0,0,n-1,m-1,dp,dir));

        // int n = 1;
        // int[] dp = new int[n+1];
        // System.out.println(boardPath(0,n,dp));
        // System.out.println(boardPath_DP(0,n,dp));
        // System.out.println(boardPath_Opti2(n));

        int n = 5;
        int k = 3;
        int[][] dp = new int[n+1][k+1];
        for(int[] a : dp) Arrays.fill(a,0);
        System.out.println(countWays_DP(n,k,dp));

        // print(dp);
        print2D(dp);
    }

    //StringSet.=====================================================================

    //Longest Plaindromic Subsequence
    public static int LPSS(String str,int i,int j,int[][] dp){
        if(i >= j){
            return dp[i][j] = (i==j?1:0);
        }

        if(dp[i][j]!=0) return dp[i][j];

        if(str.charAt(i) == str.charAt(j)) return dp[i][j] = LPSS(str,i+1,j-1,dp) + 2;
        else return dp[i][j] = Math.max(LPSS(str,i+1,j,dp),LPSS(str,i,j-1,dp));
    }

    public static int LPSS_DP(String str,int i,int j,int[][] dp){
        for(int gap =0; gap<str.length();gap++){
            for(i=0,j=gap;j<str.length();i++,j++){
                if(i >= j){
                    dp[i][j] = (i==j?1:0);
                    continue;
                }
        
                if(str.charAt(i) == str.charAt(j)) return dp[i][j] = dp[i+1][j-1] + 2;
                else return dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]);
            }
        }

        return dp[0][str.length()-1];  
    }

    
    public static String LPSS_SDP(String str,int i,int j,int[][] dp){
        String[][] sdp = new String[str.length()][str.length()];
        for(String[] s: sdp) Arrays.fill(s,"");

        for(int gap =0; gap<str.length();gap++){
            for(i=0,j=gap;j<str.length();i++,j++){
                if(i >= j){
                    dp[i][j] = (i==j?1:0);
                    if(dp[i][j]==1) sdp[i][j] = str.charAt(i);
                    continue;
                }
        
                if(str.charAt(i) == str.charAt(j)){
                    dp[i][j] = dp[i+1][j-1] + 2;
                    sdp[i][j] = str.charAt(i) + sdp[i+1][j-1] + str.charAt(j);
                }
                else{
                    dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]);
                    if(dp[i][j] == dp[i+1][j]) sdp[i][j] = sdp[i+1][j];
                    else sdp[i][j] = sdp[i][j-1];
                }
            }
        }

        return sdp[0][str.length()-1];  
    }
    
    //Leetcode 516
    public static int longestPalindromeSubseq(String s) {
        int[][] dp = new int[s.length()][s.length()];
        int ans = LPSS(s,0,s.length()-1,dp);
        
        
        return ans;
    }

    
    //Longest Plaindromic Substring
    // Leetcode 5, 647
    public static int[] LPSS_DP(String str){
        boolean[][] dp = new boolean[s.length()][s.length()];
        
        int count = 0;
        int si = 0;
        int ei =0;
        int length = 0;

        for(int gap =0; gap<str.length();gap++){
            for(i=0,j=gap;j<str.length();i++,j++){

                if(gap==0){
                    dp[i][j] = true;
                }else if(gap == 1 && str.charAt(i) == str.charAt(j)) dp[i][j] = true;
                else  dp[i][j] = str.charAt(i) == str.charAt(j) && dp[i+1][j-1];
            
                if(dp[i][j]){
                    count++;
                    if(gap + 1 > len){
                        len = gap + 1;
                        si = i;
                        ei = j;
                    }
                }
            }
        }

        return dp;  
    }

    // https://practice.geeksforgeeks.org/problems/count-palindromic-subsequences/1
    public static int countPS(String str,int i,int j,int[][] dp){
        if(i >= j){
            return dp[i][j] = (i==j?1:0);
        }

        int a = countPS(str,i+1,j-1,dp);
        int b = countPS(str,i+1,j,dp);
        int c = countPS(str,i,j-1,dp);

        if(str.charAt(i)==str.charAt(j)){
            return dp[i][j] = b + c + 1
        }else
           return dp[i][j] = b + c - a;
    }

    public static int countPS(String str,int i,int j,int[][] dp){
        
        for(int gap =0; gap<str.length();gap++){
            for(i=0,j=gap;j<str.length();i++,j++){
                
                if(i >= j){
                    dp[i][j] = (i==j?1:0);
                    continue;
                }
        
                int a = dp[i+1][j-1];//countPS(str,i+1,j-1,dp);
                int b = dp[i+1][j];//countPS(str,i+1,j,dp);
                int c = dp[i][j-1];//countPS(str,i,j-1,dp);
        
                if(str.charAt(i)==str.charAt(j)){
                    dp[i][j] = b + c + 1
                }else
                   dp[i][j] = b + c - a;     
            }
        }

        return dp[0][str.length()-1];
    }
    
    public static int numDistinct(String s, int n,String t,int m,int[][] dp){
        if(n < m) return dp[n][m] = 0;
        if(m == 0) return dp[n][m] = 1;

        if(dp[n][m] != -1) return dp[n][m];

        int count=0;
        
        if(s.charAt(n-1) == t.charAt(m-1)) count+= numDistinct(s,n-1,t,m-1,dp);
        count+=numDistinct(s,n-1,t,m,dp);

        return dp[n][m] = count;
    }



    public static int numDistinct(String s, String t) {
        int n = s.length();
        int m = t.length();
        int[][] dp = new int[n + 1][m + 1];
        for (int[] d : dp)
            Arrays.fill(d, -1);
        int ans = numDistinct(s, n,t, m, dp);
        
        // for (int[] d : dp) {
        //     for (int ele : d) {
        //         System.out.print(ele + " ");
        //     }
        //     System.out.println();
        // }
        return ans;
    }





    
  
    
    
    
    public static void solve(){
        twoPointerSet();
    }
    
    public static void main(String... args){
        solve();
    }
}

import java.util.Arrays;
public class LIScode{
    public static void main(String[] args){


    }


    public static void LIS_leftToRight(int[] arr,int[] dp){
        int n=arr.length;
        
        int max=0;
        for(int i=0;i<n;i++){
            dp[i]=1;  // at least length.
            for(int j=i-1;j>=0;j--){
                if(arr[i]>arr[j])
                  dp[i]=Math.max(dp[i],dp[j]+1);
            }

            max=Math.max(max,dp[i]);
        }
    }

    public static void LDS_leftToRight(int[] arr,int[] dp){
        int n=arr.length;
        
        int max=0;
        for(int i=0;i<n;i++){
            dp[i]=1;  // at least length.
            for(int j=i-1;j>=0;j--){
                if(arr[i] < arr[j])
                  dp[i]=Math.max(dp[i],dp[j]+1);
            }

            max=Math.max(max,dp[i]);
        }
    }

    public static void LIS_rightToleft(int[] arr,int[] dp){
        int n=arr.length;
        
        int max=0;
        for(int i=n-1;i>=0;i--){
            dp[i]=1;  // at least length.
            for(int j=i+1;j<n;j++){
                if(arr[i]>arr[j])
                  dp[i]=Math.max(dp[i],dp[j]+1);
            }

            max=Math.max(max,dp[i]);
        }
    }

    public static void LDS_rightToleft(int[] arr,int[] dp){
        int n=arr.length;
        
        int max=0;
        for(int i=n-1;i>=0;i--){
            dp[i]=1;  // at least length.
            for(int j=i+1;j<n;j++){
                if(arr[i] < arr[j])
                  dp[i]=Math.max(dp[i],dp[j]+1);
            }

            max=Math.max(max,dp[i]);
        }
    }

    //leetcode 354
    public static int maxEnvelopes(int[][] envelopes) {
        Arrays.sort(envelopes,(int[] a,int[] b)->{  //0 index is height and 1 index is width
           return a[0]-b[0];  // sort on height (increasing order: this-other)  , for reverse sorting (decreasing order:other -this)
        });
        
        int[] dp=new int[envelopes.length];
        int max=0;
        for(int i=0;i<n;i++){
            dp[i]=1;  // at least length.
            for(int j=i-1;j>=0;j--){
                if(envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1])   // both height and width should be grater for LIS.
                  dp[i]=Math.max(dp[i],dp[j]+1);
            }

            max=Math.max(max,dp[i]);
        }

        return max;
    }

    public int findNumberOfLIS(int[] arr) {
      int[] dp=new int[arr.length];
      int[] count=new int[arr.length];

      int maxLen=0;
      int maxCount=0;
      for(int i=0;i<n;i++){
          dp[i]=1;  // at least length.
          count[i]=1; // by default count is 1.
          for(int j=i-1;j>=0;j--){
              if(arr[i] > arr[j])   // both height and width should be grater for LIS.
                if(dp[j] + 1 > dp[i]){  // agar mera length update hoga to.
                    dp[i] = dp[j] + 1;
                    count[i] = count[j];
                }else if(dp[j] + 1 == dp[i]) 
                    count[i] += count[j];
          }
          
          if(dp[i] > maxLen){
              maxLen=dp[i];
              maxCount=count[i];
          }else if(dp[i] == maxLen){
              maxCount += count[i];
          }
      }
      return maxCount;
    }

    static int m=(int)1e9+7;
	public static long decodeWaysII(String s,int idx,long[] dp){
		if(idx==s.length()) return dp[idx]=1;

		if(dp[idx]!=0) return dp[idx];
		
        long count=0;
        int n=s.length();
		char ch=s.charAt(idx);
		if(ch=='*'){   // *(char) , **
           count = (count +  9*decodeWaysII(s,idx+1,dp)) % m; // value of '*' vary from 1-9
           
           if(idx + 1 < n && s.charAt(idx+1) >= '1' && s.charAt(idx+1) <= '6')  // *(char) : char vary from 1-6 it make only 2 calls of two length 
              count = (count +  2 * decodeWaysII(s,idx+2,dp)) % m; // value of '*' vary from 1-2

           if(idx + 1 < n && s.charAt(idx+1) >= '7' && s.charAt(idx+1) <= '9')  // *(char) : char vary from 7-9 it make only 2 calls of two length
               count = (count +   decodeWaysII(s,idx+2,dp)) % m; // value of '*' vary from 1-1     
            
           if(idx + 1 < n && s.charAt(idx+1) >= '*')  // ** : star vary from 1-9 it make only 15 calls of two length
               count = (count +  15*decodeWaysII(s,idx+2,dp)) % m;      
        }else if(ch!='0'){
            count = (count +  9*decodeWaysII(s,idx+1,dp)) % m; 

            if(idx + 1 < n){
                if(s.charAt(idx+1) == '*'){
                    if(s.charAt(idx) == '1')
                       count = (count +   9*decodeWaysII(s,idx+2,dp)) % m;
                    else if(s.charAt(idx) == '2')
                       count = (count +   6*decodeWaysII(s,idx+2,dp)) % m;

                }else{
                    int digit = (ch - '0') * 10 + (s.charAt(idx+1) - '0');
                    if(digit >= 10 && digit <= 26)
                      count = (count +   decodeWaysII(s,idx+2,dp)) % m; 
                }
            }


        }
}

import java.util.LinkedList;
import java.util.Arrays;
public class l001 {

	

	public static int[][] multiplication(int[][] a, int[][] b) {
		int[][] ans = new int[2][2];

		int a0 = a[0][0] * b[0][0] + a[0][1] * b[1][0];
		int a1 = a[0][0] * b[0][1] + a[0][1] * b[1][1];
		int a2 = a[1][0] * b[0][0] + a[1][1] * b[1][0];
		int a3 = a[1][0] * b[0][1] + a[1][1] * b[1][1];

		ans[0][0] = a0;
		ans[0][1] = a1;
		ans[1][0] = a2;
		ans[1][1] = a3;

		return ans;
	}

	

	//PathSeries.=============================================================

	public static int mazePathHV_rec(int sr, int sc, int er, int ec, int[][] dp) {
		if (sr == er && sc == ec) {
			dp[sr][sc] = 1;
			return 1;
		}

		if (dp[sr][sc] != 0) return dp[sr][sc];

		int count = 0;
		if (sr + 1 <= er) count += mazePathHV_rec(sr + 1, sc, er, ec, dp);

		if (sr + 1 <= er && sc + 1 <= ec) count += mazePathHV_rec(sr + 1, sc + 1, er, ec, dp);

		if (sc + 1 <= ec) count += mazePathHV_rec(sr, sc + 1, er, ec, dp);

		return dp[sr][sc] = count;
	}

	public static int mazePathHV_DP(int sr, int sc, int er, int ec, int[][] dp) {

		for (sr = er; sr >= 0; sr--) {
			for (sc = ec; sc >= 0; sc--) {

				if (sr == er && sc == ec) {
					dp[sr][sc] = 1;
					continue;
				}

				int count = 0;
				if (sr + 1 <= er) count += dp[sr + 1][sc];

				if (sr + 1 <= er && sc + 1 <= ec) count += dp[sr + 1][sc + 1];

				if (sc + 1 <= ec) count += dp[sr][sc + 1];

				dp[sr][sc] = count;
			}
		}
		return dp[0][0];
	}

	public static int mazePathMulti_rec(int sr, int sc, int er, int ec, int[][] dp) {
		if (sr == er && sc == ec) {
			dp[sr][sc] = 1;
			return 1;
		}

		if (dp[sr][sc] != 0) return dp[sr][sc];

		int count = 0;
		for (int jump = 1; sr + jump <= er; jump++)
		count += mazePathMulti_rec(sr + jump, sc, er, ec, dp);

		for (int jump = 1; sr + jump <= er && sc + jump <= ec; jump++)
		count += mazePathMulti_rec(sr + jump, sc + jump, er, ec, dp);

		for (int jump = 1; sc + jump <= ec; jump++)
		count += mazePathMulti_rec(sr, sc + jump, er, ec, dp);

		return dp[sr][sc] = count;
	}

	public static int mazePathMulti_DP(int sr, int sc, int er, int ec, int[][] dp) {

		for (sr = er; sr >= 0; sr--) {
			for (sc = ec; sc >= 0; sc--) {

				if (sr == er && sc == ec) {
					dp[sr][sc] = 1;
					continue;
				}

				int count = 0;
				for (int jump = 1; sr + jump <= er; jump++)
				count += dp[sr + jump][sc];

				for (int jump = 1; sr + jump <= er && sc + jump <= ec; jump++)
				count += dp[sr + jump][sc + jump];

				for (int jump = 1; sc + jump <= ec; jump++)
				count += dp[sr][sc + jump];

				dp[sr][sc] = count;
			}
		}

		return dp[0][0];
	}

	public static int boradPath(int si, int ei, int[] dp) {
		if (si == ei) return dp[si] = 1;

		if (dp[si] != 0) return dp[si];

		int count = 0;
		for (int dice = 1; dice <= 6; dice++) {
			if (si + dice <= ei) {
				count += boradPath(si + dice, ei, dp);
			}
		}

		return dp[si] = count;
	}

	public static int boradPath_DP(int si, int ei, int[] dp) {

		for (int i = ei; i >= si; i--) {
			if (i == ei) {
				dp[i] = 1;
				continue;
			}

			int count = 0;
			for (int dice = 1; dice <= 6; dice++) {
				if (i + dice <= ei) {
					count += dp[i + dice];
				}
			}

			dp[i] = count;
		}

		return dp[0];
	}

	public static int boradPath_02_DP(int si, int ei, int[] steps, int[] dp) {

		for (int i = ei; i >= si; i--) {
			if (i == ei) {
				dp[i] = 1;
				continue;
			}

			int count = 0;
			for (int j = 0; j < steps.length; j++) {
				if (i + steps[j] <= ei) {
					count += dp[i + steps[j]];
				}
			}

			dp[i] = count;
		}

		return dp[0];
	}

	public static int boradPath_opti(int si, int ei, int[] dp) {
		LinkedList < Integer > ll = new LinkedList < >();

		for (int i = ei; i >= si; i--) {
			if (i > ei - 2) {
				ll.addFirst(1);
				continue;
			}

			ll.addFirst(2 * ll.getFirst());
			if (ll.size() == 8) {
				int lastValue = ll.removeLast();
				ll.addFirst(ll.removeFirst() - lastValue);
			}
		}

		return ll.getFirst();
	}

	//leetcode 70.
	public static int climbStairs(int n) {
		if (n <= 1) return 1;

		int count = climbStairs(n - 1) + climbStairs(n - 2);
		return count;
	}

	public static int climbStairs_DP(int n) {
		int[] dp = new int[n + 1];

		for (int i = 0; i <= n; i++) {
			if (i <= 1) {
				dp[i] = 1;
				continue;
			}

			dp[i] = dp[i - 1] + dp[i - 2];
		}

		display(dp);
		return dp[n];
	}

	public static int climbStairs_fast(int n) {
		int a = 1;
		int b = 1;
		int ans = 1;
		for (int i = 2; i <= n; i++) {
			ans = a + b;
			a = b;
			b = ans;
		}

		return ans;
	}

	//leetcode 746
	public static int minCostClimbingStairs_(int i, int[] cost, int[] dp) {
		if (i <= 1) return cost[i];

		if (dp[i] != 0) return dp[i];
		int c1 = minCostClimbingStairs_(i - 1, cost, dp);
		int c2 = minCostClimbingStairs_(i - 2, cost, dp);

		return dp[i] = Math.min(c1, c2) + ((i != cost.length) ? cost[i] : 0);
	}

	public static void minCostClimbingStairs_DP(int i, int[] cost, int[] dp) {

		for (i = 0; i <= cost.length; i++) {
			if (i <= 1) {
				dp[i] = cost[i];
				continue;
			}

			int c1 = dp[i - 1];
			int c2 = dp[i - 2];

			dp[i] = Math.min(c1, c2) + ((i != cost.length) ? cost[i] : 0);
		}
	}

	public static int minCostClimbingStairs_fast(int[] cost) {
		int a = cost[0];
		int b = cost[1];
		int sum = 0;
		for (int i = 2; i < cost.length; i++) {

			sum = cost[i] + Math.min(a, b);
			// sum=Math.min(a,b) + ((i!=cost.length)?cost[i]:0);
			a = b;
			b = sum;
		}

		return Math.min(a, b);
	}

	public static int minCostClimbingStairs_03_(int idx, int[] cost, int[] dp) {
		if (idx >= cost.length) return 0;
		if (dp[idx] != 0) return dp[idx];

		return dp[idx] = Math.min(minCostClimbingStairs_03_(idx + 1, cost, dp), minCostClimbingStairs_03_(idx + 2, cost, dp)) + cost[idx];
	}

	public static int minCostClimbingStairs_03(int[] cost) {
		int[] dp = new int[cost.length];
		minCostClimbingStairs_03_(0, cost, dp);
		return Math.min(dp[0], dp[1]);
	}

	public int minCostClimbingStairs(int[] cost) {
		int[] dp = new int[cost.length + 1];
		// minCostClimbingStairs_(cost.length,cost,dp);
		// minCostClimbingStairs_DP(cost.length,cost,dp);

		return minCostClimbingStairs_fast(cost);

		// return dp[dp.length-1];

	}

	public static int minCostPath(int[][] cost, int sr, int sc, int[][] dp) {
		if (sr == cost.length - 1 && sc == cost[0].length - 1) return dp[sr][sc] = cost[sr][sc];

		int minAns = (int) 1e7;
		if (sr + 1 < cost.length) minAns = Math.min(minAns, minCostPath(cost, sr + 1, sc, dp));
		if (sc + 1 < cost[0].length) minAns = Math.min(minAns, minCostPath(cost, sr, sc + 1, dp));
		if (sr + 1 < cost.length && sc + 1 < cost[0].length) minAns = Math.min(minAns, minCostPath(cost, sr + 1, sc + 1, dp));

		return dp[sr][sc] = minAns + cost[sr][sc];
	}

	public static int minCostPath_DP(int[][] cost, int sr, int sc, int[][] dp) {

		for (sr = cost.length - 1; sr >= 0; sr--) {
			for (sc = cost[0].length - 1; sc >= 0; sc--) {
				if (sr == cost.length - 1 && sc == cost[0].length - 1) {
					dp[sr][sc] = cost[sr][sc];
					continue;
				}

				int minAns = (int) 1e7;
				if (sr + 1 < cost.length) minAns = Math.min(minAns, dp[sr + 1][sc]);
				if (sc + 1 < cost[0].length) minAns = Math.min(minAns, dp[sr][sc + 1]);
				if (sr + 1 < cost.length && sc + 1 < cost[0].length) minAns = Math.min(minAns, dp[sr + 1][sc + 1]);

				return dp[sr][sc] = minAns + cost[sr][sc];
			}
		}

		return dp[0][0];

	}

	public static int goldMineRec_(int[][] mat, int sr, int sc, int[][] dp) {
		if (sc == mat[0].length - 1) return dp[sr][sc] = mat[sr][sc];

		if (dp[sr][sc] != 0) return dp[sr][sc];

		int cost = 0;
		cost = Math.max(cost, (sr - 1) < 0 ? 0 : goldMineRec_(mat, sr - 1, sc + 1, dp));
		cost = Math.max(cost, goldMineRec_(mat, sr, sc + 1, dp));
		cost = Math.max(cost, (sr + 1) >= mat.length ? 0 : goldMineRec_(mat, sr + 1, sc + 1, dp));

		return dp[sr][sc] = cost + mat[sr][sc];
	}

	public static int goldMineDP(int[][] mat, int[][] dp) {

		for (int sc = mat[0].length - 1; sc >= 0; sc--) {
			for (int sr = mat.length - 1; sr >= 0; sr--) {

				if (sc == mat[0].length - 1) {
					dp[sr][sc] = mat[sr][sc];
					continue;
				}

				int cost = 0;
				cost = Math.max(cost, (sr - 1) < 0 ? 0 : dp[sr - 1][sc]);
				cost = Math.max(cost, dp[sr][sc]);
				cost = Math.max(cost, (sr + 1) >= mat.length ? 0 : dp[sr + 1][sc]);

				dp[sr][sc] = cost + mat[sr][sc];

			}
		}

		int maxAns = 0;
		for (int i = 0; i < mat.length; i++) {
			maxAns = Math.max(maxAns, dp[i][0]);
		}

		return maxAns;

	}

	public static int goldMine(int[][] mat) {
		int[][] dp = new int[mat.length][mat[0].length];
		int maxAns = 0;
		for (int i = 0; i < mat.length; i++) {
			maxAns = Math.max(maxAns, goldMineRec_(mat, i, 0, dp));
		}

		// maxAns=goldMineDP(mat,dp);

		return maxAns;
	}

	public static int pairAndSingle_01(int n, int[] dp) {
		if (n <= 1) return dp[n] = 1;
		if (dp[n] != 0) return dp[n];

		int singleWays = pairAndSingle_01(n - 1, dp);
		int pairUpWays = pairAndSingle_01(n - 2, dp) * (n - 1);

		return dp[n] = singleWays + pairUpWays;
	}

	public static int pairAndSingle_DP(int N, int[] dp) {

		for (int n = 0; n <= N; n++) {

			if (n <= 1) {
				dp[n] = 1;
				continue;
			}

			int singleWays = dp[n - 1];
			int pairUpWays = dp[n - 2] * (n - 1);

			dp[n] = singleWays + pairUpWays;
		}

		return dp[N];
	}

	public static int pairAndSingle_fast(int n) {
		if (n <= 1) return 1;

		int a = 1;
		int b = 1;
		int ans = 1;

		for (int i = 2; i <= n; i++) {
			ans = b + a * (i - 1); // b is (n-1) and a is (n-2)
			a = b;
			b = ans;
		}

		return ans;
	}

	public static int divideItemsInKGroup(int n, int k, int[][] dp) {
		if (n < k) return 0;
		if (n == k || k == 1) return dp[n][k] = 1;

		if (dp[n][k] != 0) return dp[n][k];

		int aNewSet = divideItemsInKGroup(n - 1, k - 1, dp);

		int noOfSolution = divideItemsInKGroup(n - 1, k, dp); // no of solution when A chosse to be part of created set.=
		int totalSet = noOfSolution * k;

		return dp[n][k] = aNewSet + totalSet;
	}

	public static int divideItemsInKGroup_DP(int N, int K, int[][] dp) {

		for (int n = 1; n <= N; n++) {
			for (int k = 1; k <= K; k++) {

				if (n < k) continue;
				if (n == k || k == 1) {
					dp[n][k] = 1;
					continue;
				}
				int aNewSet = dp[n - 1][k - 1];

				int noOfSolution = dp[n - 1][k]; // no of solution when A chosse to be part of created set.=
				int totalSet = noOfSolution * k;

				dp[n][k] = aNewSet + totalSet;
			}

		}

		return dp[N][K];

	}

	//stringSet.=================================================

	public static boolean[][] isPalindromicSubString(String str) {
		boolean[][] dp = new boolean[str.length()][str.length()];

		for (int gap = 0; gap < str.length(); gap++) {
			for (int si = 0, ei = gap; ei < str.length(); si++, ei++) {
				if (gap == 0) dp[si][ei] = true;
				else if (str.charAt(si) == str.charAt(ei) && gap == 1) dp[si][ei] = true;
				else dp[si][ei] = str.charAt(si) == str.charAt(ei) && dp[si + 1][ei - 1];
			}
		}

		return dp;
	}

	public static int longestPalindromicSubstring(String str) {
		int[][] dp = new int[str.length()][str.length()];
		int maxLength = 0;

		for (int gap = 0; gap < str.length(); gap++) {
			for (int si = 0, ei = gap; ei < str.length(); si++, ei++) {

				if (gap == 0) dp[si][ei] = 1;
				else if (str.charAt(si) == str.charAt(ei) && gap == 1) dp[si][ei] = 2;
				else if (str.charAt(si) == str.charAt(ei) && dp[si + 1][ei - 1] != 0) {
					dp[si][ei] = dp[si + 1][ei - 1] + 2;
				}
				maxLength = Math.max(maxLength, dp[si][ei]);
			}
		}

		return maxLength;

	}

	public static int longestPalindromicSubsubsequence_Rec(String str, int si, int ei, int[][] dp) {
		if (si > ei) return 0;
		if (si == ei) return dp[si][ei] = 1;

		if (dp[si][ei] != 0) return dp[si][ei];

		if (str.charAt(si) == str.charAt(ei)) {
			return dp[si][ei] = longestPalindromicSubsubsequence_Rec(str, si + 1, ei - 1, dp) + 2;
		}

		int strA = longestPalindromicSubsubsequence_Rec(str, si + 1, ei, dp);
		int strB = longestPalindromicSubsubsequence_Rec(str, si, ei - 1, dp);

		return dp[si][ei] = Math.max(strA, strB);
	}

	public static int longestPalindromicSubsubsequence(String str) {
		int[][] dp = new int[str.length()][str.length()];

		for (int gap = 0; gap < str.length(); gap++) {
			for (int si = 0, ei = gap; ei < str.length(); si++, ei++) {

				if (gap == 0) dp[si][ei] = 1; //length 1
				else if (str.charAt(si) == str.charAt(ei)) dp[si][ei] = dp[si + 1][ei - 1] + 2;
				else dp[si][ei] = Math.max(dp[si + 1][ei], dp[si][ei - 1]);
			}
		}

		return dp[0][str.length() - 1];
	}

	public static String longestPalindromicSubsubsequence_String(String str) {
		String[][] dp = new String[str.length()][str.length()];

		for (int gap = 0; gap < str.length(); gap++) {
			for (int si = 0, ei = gap; ei < str.length(); si++, ei++) {

				if (gap == 0) dp[si][ei] = str.charAt(si) + ""; //length 1
				else if (gap == 1 && str.charAt(si) == str.charAt(ei)) dp[si][ei] = str.substring(si, ei + 1);
				else if (str.charAt(si) == str.charAt(ei)) dp[si][ei] = str.charAt(si) + dp[si + 1][ei - 1] + str.charAt(ei);
				else dp[si][ei] = dp[si + 1][ei].length() >= dp[si][ei - 1].length() ? dp[si + 1][ei] : dp[si][ei - 1];
			}
		}

		return dp[0][str.length() - 1];
	}

	public static int countOfPalindromicSubstring(String str) {
		boolean[][] dp = new boolean[str.length()][str.length()];
		int count = 0;
		for (int gap = 0; gap < str.length(); gap++) {
			for (int si = 0, ei = gap; ei < str.length(); si++, ei++) {
				if (gap == 0) dp[si][ei] = true;
				else if (str.charAt(si) == str.charAt(ei) && gap == 1) dp[si][ei] = true;
				else dp[si][ei] = str.charAt(si) == str.charAt(ei) && dp[si + 1][ei - 1];

				count = dp[si][ei] ? count + 1 : count;
			}
		}

		return count;

	}

	public static int countOfPalindromicSubsubsequence_Rec(String str, int si, int ei, int[][] dp) {
		if (si > ei) return 0;
		if (si == ei) return dp[si][ei] = 1;

		if (dp[si][ei] != 0) return dp[si][ei];

		int middleString = countOfPalindromicSubsubsequence_Rec(str, si + 1, ei - 1, dp);
		int withoutFirstCharString = countOfPalindromicSubsubsequence_Rec(str, si + 1, ei, dp);
		int withoutLastCharString = countOfPalindromicSubsubsequence_Rec(str, si, ei - 1, dp);

		int rAns = withoutFirstCharString + withoutLastCharString;

		return dp[si][ei] = (str.charAt(si) == str.charAt(ei) ? rAns + 1 : rAns - middleString);
	}

	public static int countOfPalindromicSubsubsequence_DP(String str, int si, int ei, int[][] dp) {

		for (int gap = 0; gap < str.length(); gap++) {
			for (si = 0, ei = gap; ei < str.length(); si++, ei++) {
				if (gap == 0) dp[si][ei] = 1; //length 1
				else if (str.charAt(si) == str.charAt(ei)) dp[si][ei] = dp[si + 1][ei] + dp[si][ei - 1] + 1;
				else dp[si][ei] = dp[si + 1][ei] + dp[si][ei - 1] - dp[si + 1][ei - 1];
			}
		}

		return dp[0][str.length() - 1];
	}

	public static int longestCommonSubsequnece_Rec(String str1, String str2, int i, int j, int[][] dp) {
		if (i == str1.length() || j == str2.length()) return 0;

		if (dp[i][j] != 0) return dp[i][j];

		if (str1.charAt(i) == str2.charAt(j)) return dp[i][j] = longestCommonSubsequnece_Rec(str1, str2, i + 1, j + 1, dp) + 1;

		int a = longestCommonSubsequnece_Rec(str1, str2, i + 1, j, dp);
		int b = longestCommonSubsequnece_Rec(str1, str2, i, j + 1, dp);
		return dp[i][j] = Math.max(a, b);
	}

	static int maxAnsSubstring = 0;
	public static int longestCommonSubstring_Rec(String str1, String str2, int i, int j, int[][] dp) {
		if (i == str1.length() || j == str2.length()) return 0;

		if (dp[i][j] != -1) return dp[i][j];

		int a = 0;
		if (str1.charAt(i) == str2.charAt(j)) {
			a = longestCommonSubsequnece_Rec(str1, str2, i + 1, j + 1, dp) + 1;
			maxAnsSubstring = Math.max(maxAnsSubstring, a);
		}
		longestCommonSubsequnece_Rec(str1, str2, i + 1, j, dp);
		longestCommonSubsequnece_Rec(str1, str2, i, j + 1, dp);

		return dp[i][j] = a;
	}

	public static int longestCommonSubsequnece_DP(String str1, String str2, int i, int j, int[][] dp) {

		for (i = str1.length() - 1; i >= 0; i--) {
			for (j = str2.length() - 1; j >= 0; j--) {

				if (str1.charAt(i) == str2.charAt(j)) dp[i][j] = dp[i + 1][j + 1] + 1;
				else dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);
			}
		}

		return dp[0][0];
	}

	public static int longestCommonSubstring_DP(String str1, String str2, int i, int j, int[][] dp) {
		int max = 0;
		for (i = str1.length() - 1; i >= 0; i--) {
			for (j = str2.length() - 1; j >= 0; j--) {

				if (str1.charAt(i) == str2.charAt(j)) {
					dp[i][j] = dp[i + 1][j + 1] + 1;
					max = Math.max(dp[i][j], max);
				}
			}
		}

		return max;
	}

	public static int editDistance(String str1, String str2) {
		int[][] dp = new int[str1.length() + 1][str2.length() + 1];

		for (int i = 0; i < dp.length; i++) {
			for (int j = 0; j < dp[0].length; j++) {
				if (i == 0) dp[i][j] = j;
				else if (j == 0) dp[i][j] = i;
				else if (str1.charAt(i - 1) == str2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];
				else dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
			}
		}

		return dp[str1.length()][str2.length()];
	}

	public static int string_occurs_given_string(String str1, String str2, int n, int m, int[][] dp) {
		if (m == 0) return dp[n][m] = 1;
		if (m > n) return 0;

		if (dp[n][m] != 0) return dp[n][m];

		if (str1.charAt(n - 1) == str2.charAt(m - 1)) return dp[n][m] = string_occurs_given_string(str1, str2, n - 1, m - 1, dp) + string_occurs_given_string(str1, str2, n - 1, m, dp);

		return dp[n][m] = string_occurs_given_string(str1, str2, n - 1, m, dp);
	}

	public static int string_occurs_given_string_02(String str1, String str2, int i, int j, int[][] dp) {
		if (j == str2.length() || (i == str1.length() && j == str2.length())) return dp[i][j] = 1;
		if (i == str1.length() || (str2.length() - j) > (str1.length() - i)) return 0;

		if (dp[i][j] != 0) return dp[i][j];

		if (str1.charAt(i) == str2.charAt(j)) return dp[i][j] = string_occurs_given_string_02(str1, str2, i + 1, j + 1, dp) + string_occurs_given_string_02(str1, str2, i + 1, j, dp);

		return dp[i][j] = string_occurs_given_string_02(str1, str2, i + 1, j, dp);
	}

	public static int string_occurs_given_string_DP(String str1, String str2, int i, int j, int[][] dp) {
		for (i = str1.length(); i >= 0; i--) {
			for (j = str2.length(); j >= 0; j--) {
				if (j == str2.length() || (i == str1.length() && j == str2.length())) {
					dp[i][j] = 1;
					continue;
				}
				if (i == str1.length() || (str2.length() - j) > (str1.length() - i)) continue;

				if (str1.charAt(i) == str2.charAt(j)) dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j];
				else dp[i][j] = dp[i + 1][j];
			}
		}

		return dp[0][0];
	}

	//leetcode 940.=================================================================

	public static int distinctSubseqII(String S) {
		int[] dp=new int[S.length()+1];
		int[] lastSeen=new int[26];
		dp[0]=1;
		int mod=(int)1e9+7;

		for(int i=1;i<dp.length();i++){
			dp[i] = (dp[i-1] * 2) % mod;
			
			int idx=S.charAt(i-1)-'a';
			if(lastSeen[idx]!=0)
				dp[i] -= dp[lastSeen[idx]-1];
			
				dp[i]%=mod;
			lastSeen[idx]=i;
		}

		int ans = --dp[S.length()];
		if(ans<0) ans+=mod;
		return ans;
	}
	
	//leetcode 338.=========================================================================
	
	public static int[] countingBits(int n){
		int[] ans=new int[n+1];
		for(int i=1;i<=n;i++){
         ans[i] = ans[( i & (i-1) )]+1;
		}
		return ans;
	}

	//geeks: count-subsequences-of-type-ai-bj-ck=========================================

	public static int countSubsequnence_AiBjCk(String str){
		int emptyCount=1;
		int aCount=0;
		int bCount=0;
		int cCount=0;

		for(int i=0;i<str.length();i++){
			char ch=str.charAt(i);
			if(ch=='a')
			  aCount = aCount + (emptyCount + aCount);  // exclude + include
			
			if(ch=='b')
			  bCount = bCount + (aCount + bCount);  // exclude + include
			
			if(ch=='c')
			  cCount = cCount + (bCount + cCount);  // exclude + include
		}

		return cCount;
	}

	// https://practice.geeksforgeeks.org/problems/mobile-numeric-keypad/0

	public static int numericKeyPad_Rec(int n,int idx,int[][] dp,int[][] keyPad,int[][] dirA){
		if(n==1) return dp[n][idx] = 1;  
		
		if(dp[n][idx]!=0) return dp[n][idx];
		int r = idx / 3;
		int c = idx % 3;
		int count=0;
		for(int d=0;d<dirA.length; d++){
			int x = r + dirA[d][0];
			int y = c + dirA[d][1]; 
			if(x >= 0 && y >= 0 && x < 4 && y < 3 && keyPad[x][y] !=-1){
				count+=numericKeyPad_Rec(n-1, x*3+y, dp, keyPad, dirA);  // count+=dp[n-1][x*3+y];
			}
		}

		return dp[n][idx] = count;
	}

	public static void numericKeyPad(int n){
		int[][] dp =new int[n+1][12]; 
		int[][] keyPad ={
						{1,2,3},
						{4,5,6},
						{7,8,9},
						{-1,0,-1}};
		int[][] dirA={{0,0},{1,0},{0,1},{-1,0},{0,-1}};

		int sum=0;
		for(int i=0;i<4;i++){
			for(int j=0;j<3;j++){
				if(keyPad[i][j]!=-1){
					sum+=numericKeyPad_Rec(n , i * 3 + j,dp,keyPad, dirA);
				}
			}
		}

		return sum;
	}

	public static int numericKeyPad_DP(int N){   // N = 3 -> 138
		int[][] dp =new int[N+1][12]; 
		int[][] keyPad ={
						{1,2,3},
						{4,5,6},
						{7,8,9},
						{-1,0,-1}};
		int[][] dirA={{0,0},{1,0},{0,1},{-1,0},{0,-1}};

		int sum=0;
		for(int n=1;n<4;n++){
			for(int idx=0;idx<12;idx++){
				int r = idx / 3;
				int c = idx % 3;
				
				if(keyPad[r][c]==-1) continue;
				
				if(n==1){
					dp[n][idx] = 1;
					continue;
				}  
	
		        int count=0;
		        for(int d=0;d<dirA.length; d++){
			        int x = r + dirA[d][0];
			         int y = c + dirA[d][1]; 
			         if(x >= 0 && y >= 0 && x < 4 && y < 3 && keyPad[x][y] !=-1){
				        count+=dp[n-1][x*3+y];
			    }
		    }

		     dp[n][idx] = count;
			}
		}

		for(int i=0;i<12;i++){
			sum+=dp[N][i];
		}

		return sum;
	}




	//leetcode: decode ways 91.======================================================
	public static int numDecodings_Rec(String s,int idx,int[] dp) {
		if(idx==s.length()) return dp[idx]=1;
		
		char ch=s.charAt(idx);
		int count=0;
		
		if(dp[idx]!=0) return dp[idx];

		if(ch!='0')
		   count+=numDecodings_Rec(s,idx+1,dp);

		if(idx+1<s.length()){
			char ch2=s.charAt(idx+1);
			int val=(ch-'0')*10 + (ch2-'0');
			  if(val>=10 && val<=26)
			    count+=numDecodings_Rec(s,idx+2,dp);
		}

		return dp[idx]=count;		
	}
	
	public static int numDecodings_DP(String s,int[] dp) {
		for(int idx=s.length();idx>=0;idx--){

			if(idx==s.length()){
				dp[idx]=1;
				continue;
			}

			char ch=s.charAt(idx);
			int count=0;
			if(ch!='0')
			   count+=dp[idx+1];
	
			if(idx+1<s.length()){
				char ch2=s.charAt(idx+1);
				int val=(ch-'0')*10 + (ch2-'0');
				  if(val>=10 && val<=26)
					count+=dp[idx+2];
			}
	
		    dp[idx]=count;	
		}

		return dp[0];
    }
	
	public static int numDecodings(String s) {
		int[] dp=new int[s.length()+1];
		
		// return numDecodings_Rec(s,0,dp);
		return numDecodings_DP(s,dp);
		
	}
	
    public static int numDecodingsII(String s) {
		long[] dp=new long[s.length()+1]; 
	    return (int)decodeWaysII(s,0,dp);
    }

	static int m=(int)1e9+7;
    public static long decodeWaysII(String s,int idx,long[] dp){
	if(idx==s.length()) return dp[idx]=1;

	if(dp[idx]!=0) return dp[idx];
	
	long count=0;
	char ch=s.charAt(idx);
	if(ch=='*'){
		count=(count + 9*decodeWaysII(s,idx+1,dp))%m;
		if(idx+1< s.length()){
			char ch2=s.charAt(idx+1);
			if(ch2 >='0' && ch2<='6') count=(count + 2 * decodeWaysII(s,idx+2,dp))%m;
			if(ch2>='7' && ch2<='9') count=(count + decodeWaysII(s,idx+2,dp))%m;
			if(ch2=='*') count=(count + 15 * decodeWaysII(s,idx+2,dp))%m;
		}
		


	}else if(ch!='0'){
		  count=(count + decodeWaysII(s,idx+1,dp))%m;
		 
		  if(idx+1< s.length()){
			  char ch2=s.charAt(idx+1);
			  if(ch2=='*'){
				  if(ch =='1') count=(count + 9 * decodeWaysII(s,idx+2,dp))%m;
				  else if(ch=='2') count=(count + 6 * decodeWaysII(s,idx+2,dp))%m;


			  }else{
				int val=(ch-'0')*10 + (ch2-'0');
				if(val<=26)
				count=(count + decodeWaysII(s,idx+2,dp))%m;
			  }
		  }
	}
	return dp[idx]=count;
}

	//targetSet.===================================================================

	public static int coinChangePermuatation_Rec(int[] coins, int tar) {
		if (tar == 0) return 1;

		int count = 0;
		for (int c: coins) {
			if (tar - c >= 0) count += coinChangePermuatation_Rec(coins, tar - c);
		}

		return count;
	}

	public static int coinChangePermuatation(int[] coins, int tar) {

		int[] dp = new int[tar + 1];
		dp[0] = 1;

		for (int t = 0; t <= tar; t++) {
			for (int c: coins) {
				if (t - c >= 0) {
					dp[t] += dp[t - c];
				}
			}
		}

		return dp[tar];
	}

	public static int coinChangeCombination(int[] coins, int tar) {

		int[] dp = new int[tar + 1];
		dp[0] = 1;
		for (int c: coins) {
			for (int t = 0; t <= tar; t++) {
				if (t - c >= 0) {
					dp[t] += dp[t - c];
				}
			}
		}

		return dp[tar];
	}

	public static int linearEquationOfNvariables(int[] coeff, int y) {
		return coinChangeCombination(coeff, y);
	}

	//leetcode 322
	public int coinChangeMinHeight_rec(int[] coins, int tar, int[] dp) {
		if (tar == 0) return 0;

		if (dp[tar] != 0) return dp[tar];

		int height = (int) 1e8;
		for (int c: coins) {
			if (tar - c >= 0) {
				int recH = coinChangeMinHeight_rec(coins, tar - c, dp);
				if (recH != (int) 1e8) height = Math.min(height, recH + 1);
			}
		}

		return dp[tar] = height;
	}

	public int coinChangeMinHeight_DP(int[] coins, int tar, int[] dp) {
		Arrays.fill(dp, 100000000);
		dp[0] = 0;

		for (int t = 1; t <= tar; t++) {
			for (int c: coins) {
				if (t - c >= 0) {
					// dp[t]=Math.min(dp[t],dp[t-c]+1);
					int recH = dp[t - c];
					if (recH != (int) 1e8) dp[t] = Math.min(dp[t], recH + 1);
				}
			}
		}

		return dp[tar];
	}

	public int coinChange(int[] coins, int tar) {
		int[] dp = new int[tar + 1];
		int ans = 0;
		// ans=coinChangeMinHeight_rec(coins,tar,dp);
		ans = coinChangeMinHeight_DP(coins, tar, dp);

		return ans != (int) 1e8 ? ans: -1;
	}

	public static int targetSum(int[] arr, int tar, int idx, int[][] dp) { // dp: arr X tar
		if (tar == 0 || idx == arr.length) {
			return dp[idx][tar] = tar == 0 ? 1 : 0;
		}

		if (dp[idx][tar] != 0) return dp[idx][tar];

		int count = 0;
		if (tar - arr[idx] >= 0) count += targetSum(arr, tar - arr[idx], idx + 1, dp);

		count += targetSum(arr, tar, idx + 1, dp);

		return dp[idx][tar] = count;
	}

	public static int targetSum_DP(int[] arr, int tar, int[][] dp) { // dp: arr X tar
		dp[0][0] = 1;

		for (int idx = 1; idx < dp.length; idx++) {
			for (int t = 0; t <= tar; t++) {

				int count = 0;
				if (t - arr[idx - 1] >= 0) {
					count += dp[idx - 1][t - arr[idx - 1]];
				}
				count += dp[idx - 1][t];

				dp[idx][t] = count;
			}
		}

		return dp[dp.length - 1][dp[0].length - 1];
	}

	int knapsack_01_rec(int[] weight, int[] value, int w, int idx, int[][] dp) { // dp: weight X W
		if (w == 0 || idx == weight.length) {
			return 0;
		}
		if (dp[idx][w] != 0) return dp[idx][w];

		int pick = 0;
		if (w - weight[idx] >= 0) {
			pick = knapsack_01_rec(weight, value, w - weight[idx], idx + 1, dp) + value[idx];
		}

		int notPicked = knapsack_01_rec(weight, value, w, idx + 1, dp);

		return dp[idx][w] = Math.max(pick, notPicked);
	}

	int knapsack_01_rec_01(int[] weight, int[] value, int w, int n, int[][] dp) { // dp: weight X W, n is size of weight
		if (w == 0 || n == 0) {
			return 0;
		}
		if (dp[n][w] != 0) return dp[n][w];

		int pick = 0;
		if (w - weight[n - 1] >= 0) {
			pick = knapsack_01_rec(weight, value, w - weight[n - 1], n - 1, dp) + value[n - 1];
		}

		int notPicked = knapsack_01_rec(weight, value, w, n - 1, dp);

		return dp[n][w] = Math.max(pick, notPicked);
	}

	int knapsack_01_rec_DP(int[] weight, int[] value, int W, int[][] dp) { // dp: weight X W, n is size of weight
		dp[0][0] = 0;
		for (int idx = 1; idx < dp.length; idx++) {
			for (int w = 0; w <= W; w++) {

				int pick = 0;
				if (w - weight[idx - 1] >= 0) {
					pick = dp[idx - 1][w - weight[idx - 1]] + value[idx - 1];
				}

				int notPicked = dp[idx - 1][w];

				dp[idx][w] = Math.max(pick, notPicked);
			}
		}

		return dp[dp.length - 1][dp[0].length - 1];
	}

	int unBoundedKnapsack(int[] weight, int[] value, int W) {
		int[] dp = new int[W + 1];

		for (int idx = 0; idx < weight.length; idx++) {
			for (int w = 1; w <= W; w++) {
                int picked=0;
				if (w - weight[idx] >= 0) picked = dp[w - weight[idx]] + value[idx];
				int unPicked = dp[w];

				dp[w] = Math.max(picked, unPicked);
			}
		}

		return dp[W];
	}

	//LIS_Type.=================================================================

	// LIS from left to right
	public static int LIS_DP(int[] arr, int[] dp) {

		dp[0] = 1;
		int maxLen = 0;
		for (int i = 1; i < arr.length; i++) {
			dp[i] = 1;
			for (int j = 0; j < i; j++) { // har ek j cell apne ko include krke apne tak ka maximum Increasing subsequnece store krke rakhta hai.
				if (arr[i] > arr[j]) { // if i'th cell element is grater than j'th cell element than length will increase by 1.
					dp[i] = Math.max(dp[i], dp[j] + 1);
				}
			}
			maxLen = Math.max(maxLen, dp[i]);
		}

		return maxLen;
	}


	//LIS from right to left
	public static int LDS_DP(int[] arr, int[] dp) {
        int n=arr.length;
		dp[n-1] = 1;
		int maxLen = 0;
		for (int i = n-2 ; i >= 0 ;i--) {
			dp[i] = 1;
			for (int j = i+1; j < n; j++) { // har ek j cell apne ko include krke apne tak ka maximum Increasing subsequnece store krke rakhta hai.
				if (arr[i] > arr[j]) { // if i'th cell element is grater than j'th cell element than length will increase by 1.
					dp[i] = Math.max(dp[i], dp[j] + 1);
				}
			}
			maxLen = Math.max(maxLen, dp[i]);
		}

		return maxLen;
	}

	public static int LBS_DP(int[] arr){
	    int n=arr.length;

		int[] LIS=new int[n];
		int[] LDS=new int[n];

		LIS_DP(arr,LIS);
		LDS_DP(arr,LDS);

		int maxLen = 0;
		for(int i=0;i<n;i++){
			int bitonicLen=LIS[i]+LDS[i]-1;
			maxLen=Math.max(maxLen,bitonicLen);
		}

		return maxLen;
	}

	public static int maximumSumIncreasingSubsequnece(int[] arr){
		int n=arr.length;
		int[] dp=new int[n];
        int maxSum=0;
		for(int i=0;i<n;i++){
			  dp[i]=arr[i];
			for(int j=0;j<i;j++){
				if(arr[i]>arr[j]){
					dp[i]=Math.max(dp[i],dp[j]+arr[i]);
				}
			}
			maxSum=Math.max(maxSum,dp[i]);
		}

		return maxSum;
	}
	
	// minimum no of deletion to make array in sorted order in increasing order.
	public static int minimum_No_of_deletion(int[] arr){
		int n=arr.length;
		int[] dp=new int[n];

		dp[0] = 1;
		int maxLen = 0;
		for (int i = 1; i < arr.length; i++) {
			dp[i] = 1;
			for (int j = 0; j < i; j++) { 
				if (arr[i] >= arr[j]) { 
					dp[i] = Math.max(dp[i], dp[j] + 1);
				}
			}
			maxLen = Math.max(maxLen, dp[i]);
		}

		return n-maxLen;
	}

	public static int LDS_from_left_right(int[] arr,int[] dp){
		int n=arr.length;
		dp[0]=1;

		int maxLen = 0;
		for(int i=1;i<n;i++){
			dp[i]=1;
			for(int j=0;j<i;j++){
				if(arr[i]<arr[j])
				dp[i] = Math.max(dp[i], dp[j] + 1);
			}
		   maxLen = Math.max(maxLen, dp[i]);

		}

		return maxLen;
	}

	public static int LDS_from_Right_left(int[] arr,int[] dp){
		int n=arr.length;
		dp[n-1]=1;
        
        int maxLen = 0;
		for(int i=n-2;i>=0;i--){
			dp[i]=1;
			for(int j=i+1;j<n;j++){
				if(arr[i]<arr[j])
				dp[i] = Math.max(dp[i], dp[j] + 1);
			}
		   maxLen = Math.max(maxLen, dp[i]);
		}

		return maxLen;
	}

	public static int LBS_DP_02(int[] arr){
	    int n=arr.length;

		int[] LIS=new int[n];
		int[] LDS=new int[n];

		LDS_from_left_right(arr,LIS);
		LDS_from_Right_left(arr,LDS);

		int maxLen = 0;
		for(int i=0;i<n;i++){
			int bitonicLen=LIS[i]+LDS[i]-1;
			maxLen=Math.max(maxLen,bitonicLen);
		}

		return maxLen;
	}
	
	// leetcode 673
	public static int findNumberOfLIS(int[] arr) {
		if(arr.length<=1) return arr.length;
		
		int n=arr.length;
		int[] dp=new int[n];
		int[] count=new int[n];
		
		int maxLen=0;
		int maxCount=0;
		
		for(int i=0;i<n;i++){
			dp[i]=1;
			count[i]=1;
			for(int j=0;j<i;j++){
			  if(arr[i]>arr[j]){
                 if(dp[j] + 1 > dp[i]){
					 dp[i]=dp[j]+1;
					 count[i]=count[j];
				 }else if(dp[j]+1==dp[i]){
					 count[i]+=count[j];
				 }
			  }	
			}

			if(dp[i]>maxLen){
				maxLen=dp[i];
				maxCount=count[i];
			}else if(dp[i]==maxLen){
				maxCount+=count[i];
			}
		}

		return maxCount;

		
	}

	//leetcode 354 =================================================

	public static int maxEnvelopes(int[][] arr) {

		Arrays.sort(arr,(a, b)->{ 
			// 0'th index-> width and 1'st index -> height, 
			// for C++: sort(arr.begin(),arr.end(),[](vector<int>& a,vector<int>& b){ //logic });
			if(a[0]==b[0]) return b[1] - a[1];   // reverse sort.  for c++ replace '-' with '<'
			else return a[0]-b[0];   // default sort.  for c++ replace '-' with '<'
		});

		int n=arr.length;
		int[] dp=new int[n];
		int maxLen = 0;
		for (int i =0;i<n;i++) {
			dp[i] = 1;
			for (int j = 0; j < i; j++) { 
				if (arr[i][1] > arr[j][1]) { // compare height. 
					dp[i] = Math.max(dp[i], dp[j] + 1);
				}
			}
			maxLen = Math.max(maxLen, dp[i]);
		}

		return maxLen;
	}
	
	
	//cutTypeQuestion.=====================================================

	public static int MCM_rec(int[] arr,int st,int end,int[][] dp){
		if(st+1==end) return dp[st][end] = 0;
		
		if(dp[st][end]!=-1) return dp[st][end];

        int min_=(int) 1e8;
		for(int cut=st+1;cut<end;cut++){
			int leftOptimalCost=MCM_rec(arr,st,cut,dp);
			int rightOptimalCost=MCM_rec(arr,cut,end,dp);

			int myCost=leftOptimalCost +  arr[st] * arr[cut] * arr[end]   + rightOptimalCost;
            min_=Math.min(min_,myCost);
		}

		return dp[st][end]=min_;
	}

	public static int MCM_DP(int[] arr,int n,int[][] dp,String[][] sdp){
		for(int gap=1;gap<n;gap++){
			for(int st=0,end=gap;end<n;st++,end++){
				if(st+1==end) {
					dp[st][end] = 0;
					sdp[st][end]=(char)(st+'A') + "";
				    continue;
				}

				int min_=(int) 1e8;
				String mins="";
		        for(int cut=st+1;cut<end;cut++){
			        int leftOptimalCost=dp[st][cut];
			        int rightOptimalCost=dp[cut][end];

			        int myCost=leftOptimalCost +  arr[st] * arr[cut] * arr[end]   + rightOptimalCost;
					
					if(myCost<min_){
						min_=myCost;
						mins=  "(" + sdp[st][cut]+sdp[cut][end] + ")";
					}
		        }

				dp[st][end]=min_;
				sdp[st][end]=mins;
				
			}

		}
		System.out.print(sdp[0][n-1] + " -> ");
		return dp[0][n-1];
	}

	//leetcode 132.===========================================================
	//Time: O(n3)
	public static int minCut_(int st,int end,int[][] dp,boolean[][] isPalindrome){
		if(st==end || isPalindrome[st][end]) return dp[st][end]=0; 
		
		if(dp[st][end]!=-1) return dp[st][end];

        int min_=(int) 1e8;
		for(int cut=st;cut<end;cut++){
			int leftMinCut=isPalindrome[st][cut]?0:minCut_(st,cut,dp,isPalindrome);
			int rightMinCut=isPalindrome[cut+1][end]?0:minCut_(cut+1,end,dp,isPalindrome);

			int myCost=leftMinCut +  1   + rightMinCut;
            min_=Math.min(min_,myCost);
		}

		return dp[st][end]=min_;
	}

    //Time: O(n2)
	public static int minCut_02(int st,int end,int[] dp,boolean[][] isPalindrome){
		if(st>end) return -1;
		if(dp[st]!=-1) return dp[st];

        int min_=(int) 1e8;
		for(int cut = st;cut <=end;cut++){
			if(isPalindrome[st][cut]){
				int cuts_ = minCut_02(cut+1,end,dp,isPalindrome)+1;
				min_=Math.min(min_,cuts_);
			}
		}

		return dp[st]=min_;
	}

	public static int minCut_02_DP(int st,int end,int[] dp,boolean[][] isPalindrome){
		for( st=end;st>=0;st--){
			int min_=(int) 1e8;
			for(int cut = st;cut <=end;cut++){
				if(isPalindrome[st][cut]){
					int cuts_ = (( cut + 1==end+1 )? -1 : dp[cut+1]) + 1;
					min_=Math.min(min_, cuts_);
				}
			}
	
			dp[st]=min_;
		}
		return dp[0];
	}


	public static int minCut(String str) {
		int n=str.length();
		int[] dp=new int[n];
		boolean[][] isPalindrome=new boolean[n][n];

		for(int i=0;i<n;i++) dp[i]=-1;

		for (int gap = 0; gap < n; gap++) {
			for (int si = 0, ei = gap; ei < n; si++, ei++) {
				if (gap == 0) isPalindrome[si][ei] = true;
				else if (str.charAt(si) == str.charAt(ei) && gap == 1) isPalindrome[si][ei] = true;
				else isPalindrome[si][ei] = str.charAt(si) == str.charAt(ei) && isPalindrome[si + 1][ei - 1];
			}
		}

		return minCut_02(0,n-1,dp,isPalindrome);
	}

	public static int totalFreqinRange(int[] freq,int si,int ei){
		int sum=0;
		for(int i=si;i<=ei;i++){
			sum+=freq[i];
		}
		return sum;
	}
	
	public static void OBST_rec(int[] keys,int[] freq,int si,int ei,int[][] dp){
		if(dp[si][ei]!=0) dp[si][ei];
		
		int min=(int)1e8;
		for(int root=si;root<=ei;root++){
			int leftSubTree=(root==st)?0:OBST_rec(keys, freq, si, root-1,dp);
			int rightSubTree=(root==ei)?0:OBST_rec(keys,freq, root+1, ei,dp);

			int myCost=leftSubTree + totalFreqinRange(freq,si,ei) + rightSubTree;
			
			min=Math.min(min,myCost);
		}

		
		return dp[si][ei]=min;
	}

	public static int OBST_DP(int[] keys,int[] freq,int si,int ei,int[][] dp){
		for(int gap=1;gap<n;gap++){
			for( si=0,ei=gap;end<n;si++,ei++){
				int min=(int)1e8;
		        for(int root=si;root<=ei;root++){
			        int leftSubTree=(root==st)?0:dp[si][root-1];
			        int rightSubTree=(root==ei)?0:dp[root+1][ei];

			        int myCost = leftSubTree + rightSubTree;
			
			        min=Math.min(min,myCost);
		        }

		        dp[si][ei]=min +  (min==(int)1e8? 0 : totalFreqinRange(freq,si,ei));

			}
		}
	}


	public static int wildCard_rec(String s,String p,int i,int j,int[][] dp){
		if(i==s.length() && j==p.length()) return dp[i][j]=1;
		if(i==s.length() || j==p.length()){
			if( i!=s.length() ) return  dp[i][j]=0;
			
			return dp[i][j]= (p.charAt(j)=='*' && p.length() - j == 1)?1:0;
		}

		if(dp[i][j]!=-1) return dp[i][j];

		char ch1=s.charAt(i);
		char ch2=p.charAt(j);
		boolean res=false;
		if(ch1 == ch2 || ch2 == '?') res = wildCard_rec(s,p,i+1,j+1,dp)==1;
		else if(ch2=='*'){
			res = res || wildCard_rec(s,p,i,j+1,dp)==1;  // as a empty string mapping ('*' treated as a "").
			res = res || wildCard_rec(s,p,i+1,j,dp)==1;  // sequence mapping.("*" treated as a substring).
		}

		return dp[i][j]=res?1:0;
	}

	public static String removeStar(String str){
	  StringBuilder sb=new StringBuilder();
	  boolean firstStar=false;
	  for(int i=0;i<str.length();i++){
		char ch=str.charAt(i);  
		if(ch=='*'){
			if(!firstStar) sb.append(ch);
			firstStar=true;
		}else{
			sb.append(ch);
			firstStar=false;
		}
	  }

	 return sb.toString();
	}

	public static boolean isMatch(String s, String p) {
		
		p=removeStar(p);
		int[][] dp=new int[s.length()+1][p.length()+1];
		for(int i=0;i<s.length();i++) for(int j=0;j<p.length();j++) dp[i][j]=-1;
		return  wildCard_rec(s,p,0,0,dp)==1;
	}
	
	//LEETCODE 312.===========================================

	public int maxCoins(int[] nums,int si,int ei,int[][] dp) {
		if(dp[si][ei]!=0) return dp[si][ei];
		int l =((si-1 == -1)? 1 : nums[si-1]);
		int r = ( (ei+1 == nums.length)? 1 : nums[ei+1]);
		int maxCost=0;
		for(int cut=si;cut<=ei;cut++){

			int leftCost= (cut==si) ? 0 : maxCoins(nums,si,cut-1,dp);
			int rightCost= (cut==ei) ? 0 : maxCoins(nums,cut+1,ei,dp);
			int myCost = leftCost + (l * nums[cut] * r) + rightCost;
			
			maxCost=Math.max(maxCost,myCost);
		}

		return dp[si][ei]=maxCost;
    }

	public int maxCoins(int[] nums) {
		int[][] dp=new int[nums.length][nums.length];
		return maxCoins(nums,0,nums.length-1,dp);
	}

	//leetcode 139.======================================================

	public boolean wordBreak(String s, List<String> wordDict) {
		HashSet<String> words=new HashSet(wordDict);
		int n=s.length();
		boolean[] dp=new boolean[n+1];
		
		int len=0;
		for(String word: wordDict) len=Math.max(len,word.length());
		
		dp[0]=true;
		for(int i=0;i<n;i++){
			if(!dp[i]) continue;
			
			for(int l=1;i+l<=n && l <= len ; l++){
				if(words.contains(s.substring(i,i+l))) dp[i+1]=true;
			}
		}

		return dp[n];
    }





	public static void PathSeries() {
		int er = 3;
		int ec = 3;
		int sr = 0;
		int sc = 0;

		int ans = 0;
		// int[][] dp = new int[er + 1][ec + 1];

		// ans = mazePathHV_rec(sr, sc, er, ec, dp);

		// ans = mazePathMulti_rec(sr, sc, er, ec, dp);
		// ans = mazePathMulti_DP(sr, sc, er, ec, dp);

		// int si=0;
		// int ei=10;
		// int[] dp=new int[ei+1];
		// ans=boradPath(si,ei,dp);
		// ans=boradPath_DP(si,ei,dp);
		// ans=boradPath_opti(si,ei,dp);

		// climbStair_DP(8);

		// goldMine(arr);

		// int n = 6;
		// int[] dp = new int[n + 1];
		// ans = pairAndSingle_01(n, dp);

		int n = 11,
		k = 4;
		int[][] dp = new int[n + 1][k + 1];
		// ans = divideItemsInKGroup(n, k, dp);
		ans = divideItemsInKGroup_DP(n, k, dp);

		// display(dp);
		display2D(dp);
		System.out.println(ans);

	}

	public static void stringSet() {
		 // String str="geeksse";
		// int[][] dp=new int[str.length()][str.length()];
		// System.out.println(longestPalindromicSubsubsequence_Rec(str,0,str.length()-1,dp));
		// System.out.println(longestPalindromicSubsubsequence(str));
		// System.out.println(longestPalindromicSubsubsequence_String(str));

		// String str="baccbab";
		// int[][] dp=new int[str.length()][str.length()];
		// // System.out.println(countOfPalindromicSubsubsequence_Rec(str,0,str.length()-1,dp));
		// System.out.println(countOfPalindromicSubsubsequence_DP(str,0,str.length()-1,dp));

		// String str1="abcde";
		// String str2="ace";
		// int[][] dp=new int[str1.length()+1][str2.length()+1];
		// System.out.println(longestCommonSubsequnece_Rec(str1,str2,0,0,dp));
		// System.out.println(longestCommonSubstring_Rec(str1,str2,0,0,dp));

		String str1 = "aabbcc";
		String str2 = "abc";
		int[][] dp = new int[str1.length() + 1][str2.length() + 1];
		// System.out.println(string_occurs_given_string_DP(str1,str2,0,0,dp));
		// System.out.println(string_occurs_given_string_02(str1,str2,0,0,dp));
		System.out.println(string_occurs_given_string(str1, str2, str1.length(), str2.length(), dp));

		display2D(dp);
	}

	public static void targetSet() {
		int[] arr={2,3,1,5,6};
		// int[] arr = {1,1,1,1,1};
		int tar = 3;
		int ans = 0;

		int[][] dp = new int[arr.length + 1][tar + 1];
		// ans=targetSum(arr,tar,0,dp);
		// ans += targetSum_DP(arr, tar, dp);

		// display(dp);
		display2D(dp);
		System.out.println(ans);
	}

	public static void LIS_Type() {
		// int[] arr = {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15};
		int[] arr={1,3,5,4,7};
		int[] dp=new int[arr.length];

		int ans=0;
		// ans = LIS_DP(arr,dp);
		// ans = LDS_DP(arr,dp);
		// ans =LBS_DP(arr);

		ans=findNumberOfLIS(arr);

		
		System.out.println(ans);
		// display(dp);
	}

	public static void cutType(){
		int[] arr={10, 20, 30, 40, 30};
		int ans=0;
		int n=arr.length;

		int[][] dp=new int[n][n];
		String[][] sdp=new String[n][n];
		for(int i=0;i<n;i++) for(int j=0;j<n;j++) dp[i][j]=-1;

		// ans=MCM_rec(arr,0,n-1,dp);
		// ans=MCM_DP(arr,n,dp,sdp);
		String str="bbbbbb";
		ans=minCut(str);


		System.out.println(ans);
		display2D(dp);
	}
	

	//util.=================================================================

	public static void display2D(int[][] arr) {
		for (int[] ar: arr) {
			for (int ele: ar) {
				System.out.print(ele + " ");
			}
			System.out.println();
		}
		System.out.println();
	}

	public static void display(int[] arr) {
		for (int ele: arr) System.out.print(ele + " ");
		System.out.println();
	}

	public static void solve() {
		// basic();
		// PathSeries();
		// stringSet();
		// targetSet();
		// LIS_Type();
		cutType();

	}
}

import java.util.LinkedList;
import java.util.ArrayList;
import java.util.Arrays;
public class l001{
    public static void print(int[] arr){
        for(int ele: arr)
        System.out.print(ele+" ");

        System.out.println();
    }

    public static void print2D(int[][] arr){
        for(int[] ar: arr) print(ar);
        System.out.println();
    }

    

    public static int mazePath_HVD(int sr,int sc,int er,int ec,int[][] dp){
        if(sr==er && sc==ec){
            return dp[sr][sc] = 1;
        }

        if(dp[sr][sc]!=0) return dp[sr][sc];
        int count=0;
        
        if(sc+1 <= ec) count+=mazePath_HVD(sr,sc+1,er,ec,dp);
        if(sr+1 <= er && sc+1 <= ec)count+=mazePath_HVD(sr+1,sc+1,er,ec,dp);
        if(sr+1 <= er)count+=mazePath_HVD(sr+1,sc,er,ec,dp);
        
        return dp[sr][sc] = count;
    }

    public static int mazePath_HVD_DP(int sr,int sc,int er,int ec,int[][] dp){
     
        for(sr=er;sr>=0;sr--){
            for(sc=ec;sc>=0;sc--){
                if(sr==er && sc==ec){
                    dp[sr][sc] = 1;
                    continue;
                }
        
                int count=0;
                
                if(sc+1 <= ec) count+=dp[sr][sc+1];//mazePath_HVD(sr,sc+1,er,ec,dp);
                if(sr+1 <= er && sc+1 <= ec)count+=dp[sr+1][sc+1];//mazePath_HVD(sr+1,sc+1,er,ec,dp);
                if(sr+1 <= er)count+=dp[sr+1][sc];//mazePath_HVD(sr+1,sc,er,ec,dp);
                
               dp[sr][sc] = count;
            }
        }
        return dp[0][0];
    }

    public static int mazePath_HVDJump_DP(int sr,int sc,int er,int ec,int[][] dp){
     
        for(sr=er;sr>=0;sr--){
            for(sc=ec;sc>=0;sc--){
                if(sr==er && sc==ec){
                    dp[sr][sc] = 1;
                    continue;
                }
        
                int count=0;
                
                for(int jump=1; sc+jump <= ec; jump++) count+=dp[sr][sc+jump];//mazePath_HVD(sr,sc+1,er,ec,dp);
                for(int jump=1; sr+jump <= er && sc+jump <= ec; jump++)count+=dp[sr+jump][sc+jump];//mazePath_HVD(sr+1,sc+1,er,ec,dp);
                for(int jump=1; sr+jump <= er; jump++)count+=dp[sr+jump][sc];//mazePath_HVD(sr+1,sc,er,ec,dp);
                
               dp[sr][sc] = count;
            }
        }
        return dp[0][0];
    }

    public static int boardPath(int si,int ei,int[] dp){
        if(si==ei){
            return dp[si] = 1;
        }

        if(dp[si]!=0) return dp[si];

        int count=0;
        for(int dice = 1; dice <= 6 && si + dice <= ei ; dice++){
            count+=boardPath(si+dice,ei,dp);
        }

        return dp[si] = count;
    }

    public static int boardPath_DP(int si,int ei,int[] dp){
        for(si=ei;si>=0;si--){
            if(si==ei){
                dp[si] = 1;
                continue;
            }
    
            int count=0;
            for(int dice = 1; dice <= 6 && si + dice <= ei ; dice++){
                count+=dp[si+dice]; //boardPath(si+dice,ei,dp);
            }

            dp[si] = count;
        }
        
        return dp[0];
    }

    public static int boardPath_Opti(int si,int ei,int[] dp){
        LinkedList<Integer> ll = new LinkedList<>();
        for(si=ei;si>=0;si--){
            if(si>=ei-1){
                ll.addFirst(1);
                continue;
            }

            if(ll.size()<=6) ll.addFirst(ll.getFirst()*2);
            else{
                int lval = ll.removeLast();
                ll.addFirst(ll.getFirst()*2 - lval);
            }
        }
        
        return ll.getFirst();
    }


    
    //leetcode 746

    public int minCostClimbingStairs(int[] cost, int n, int[] dp) {
        if(n<=1) return dp[n]=cost[n];
        if(dp[n]!=0) return dp[n];
        
        int ans = Math.min(minCostClimbingStairs(cost,n-1,dp),minCostClimbingStairs(cost,n-2,dp));

        return dp[n] = ans + (n != cost.length ? cost[n] : 0);
    }

    public int minCostClimbingStairs_DP(int[] cost, int n, int[] dp) {
        for(n=0;n<=cost.length;n++){
            if(n<=1){
                dp[n]=cost[n];
                continue;
            }

            int ans = Math.min(dp[n-1],dp[n-2]);
            dp[n] = ans + (n != cost.length ? cost[n] : 0);
        }
        
        return dp[cost.length];
    }

    public  int minCostClimbingStairs(int[] cost) {
        int[] dp = new int[cost.length + 1];
        int ans = minCostClimbingStairs(cost,dp.length,dp);
        // ans = minCostClimbingStairs_DP(cost,dp.length,dp);
        return ans;
    }


    public static int boardPath_Moves(int si,int ei,int[] moves,int[] dp){
        Arrays.sort(moves);
        for(si=ei;si>=0;si--){
            if(si==ei){
                dp[si] = 1;
                continue;
            }
    
            int count=0;
            for(int i = 0; si + moves[i] <= ei ; i++){
                count+=dp[si + moves[i]]; //boardPath(si+dice,ei,dp);
            }

            dp[si] = count;
        }
        
        return dp[0];
    }

    //Leetcode 64    
    public static int minPathSum(int[][] grid,int sr,int sc,int[][] dp) {
        if(sr==grid.length-1 && sc==grid[0].length-1){
            return dp[sr][sc] = grid[sr][sc];
        }

        if(dp[sr][sc]!=0) return dp[sr][sc];

        int minCost = (int)1e8;
        if(sr + 1 < grid.length) minCost = Math.min(minCost,minPathSum(grid,sr+1,sc,dp));
        if(sc + 1 < grid[0].length) minCost = Math.min(minCost,minPathSum(grid,sr,sc+1,dp));
        
        return dp[sr][sc] = minCost + grid[sr][sc];
    }

    
    public static int minPathSum_DP(int[][] grid,int sr,int sc,int[][] dp) {
        
        for(sr=grid.length-1;sr>=0 ;sr--){
            for(sc=grid[0].length-1; sc>=0 ; sc--){
               if(sr==grid.length-1 && sc==grid[0].length-1){
                    dp[sr][sc] = grid[sr][sc];
                    continue;
                }
                int minCost = (int)1e8;
                if(sr + 1 < grid.length) minCost = Math.min(minCost,dp[sr+1][sc]);
                if(sc + 1 < grid[0].length) minCost = Math.min(minCost,dp[sr][sc+1]);
        
                dp[sr][sc] = minCost + grid[sr][sc];         
            }
        }

        return dp[0][0];
    }

    
    public static int minPathSum(int[][] grid) {
        int[][] dp = new int[grid.length][grid[0].length];
        // int ans= minPathSum(grid,0,0,dp);
        int ans= minPathSum_DP(grid,0,0,dp);

        return ans;
    }

    public static int goldMineProblem(int[][] coins,int sr,int sc,int[][] dp,int[][] dir){
        if(sc==coins[0].length-1){
            return dp[sr][sc] = coins[sr][sc];
        }

        if(dp[sr][sc]!=0) return dp[sr][sc];

        for(int d=0;d<3;d++){
            int r = sr + dir[d][0];
            int c = sc + dir[d][1];

            if(r>=0 && c>=0 && r < coins.length && c < coins[0].length){
                dp[sr][sc] = Math.max(dp[sr][sc], goldMineProblem(coins,r,c,dp,dir) + coins[sr][sc]);
            }
        }

        return dp[sr][sc];
    }

    
    public static int goldMineProblem_DP(int[][] coins,int sr,int sc,int[][] dp,int[][] dir){
        for(sc = coins[0].length - 1;sc>=0;sc--){
            for(sr = coins.length - 1; sr>=0;sr--){
                if(sc==coins[0].length-1){
                    dp[sr][sc] = coins[sr][sc];
                    continue; 
                }
                
                for(int d=0;d<3;d++){
                     int r = sr + dir[d][0];
                     int c = sc + dir[d][1];
         
                     if(r>=0 && c>=0 && r < coins.length && c < coins[0].length){
                        dp[sr][sc] = Math.max(dp[sr][sc], dp[r][c]  + coins[sr][sc]);
                     }
                 }
            }
        }

        int max = 0;
        for(int i=0;i<coins.length;i++){
            max = Math.max(max, dp[i][0]);
        }

        return max;
    }

    public static int goldMineProblem(){
        int[][] coins={{10, 33, 13, 15},
                        {22, 21, 04, 1},
                        {5, 0, 2, 3},
                        {0, 6, 14, 2}};
        int[][] dp = new int[coins.length][coins[0].length];
        int[][] dir = {{-1,1},{0,1},{1,1}};

        int max = 0;
        // for(int i=0;i<coins.length;i++){
        //     max = Math.max(max, goldMineProblem(coins,i,0,dp,dir));
        // }

        max=goldMineProblem_DP(coins,0,0,dp,dir);

        print2D(dp);
        return max;
    }

    //geeksforgeeks.org/friends-pairing-problem/
    public static int frindsPairing(int n,int[] dp){
        if(n<=1){
            return dp[n] = 1;
        }

        if(dp[n]!=0) return dp[n];

        int single = frindsPairing(n-1,dp);
        int pairUp = frindsPairing(n - 2,dp) * (n-1);

        return dp[n] = single + pairUp;
    }

    public static int frindsPairing_DP(int N,int[] dp){
        
        for(int n=0;n <= N;n++){
            if(n<=1){
                dp[n] = 1;
                continue;
            }

            int single = dp[n-1];//frindsPairing(n-1,dp);
            int pairUp = dp[n-2]*(n-1);//frindsPairing(n - 2,dp) * (n-1);
            dp[n] = single + pairUp;

            // dp[n] = dp[n-1] + dp[n-2] * (n-1);
        }

        return dp[N];
    }

    public static int frindsPairing_Opti(int N,int[] dp){
        int a = 1;
        int b = 1;
        for(int i=2; i <= N;i++){
            int sum = a * (i-1) + b;
            a = b;
            b = sum;
        }

        return b;
    }

    public static void frindsPairing(){
        int n=84;
        int[] dp =new int[n+1];
        int ans = frindsPairing(n,dp);

        print(dp);
        System.out.println(ans);
    }
 
    public static int count_of_ways(int n,int k,int[][] dp){
        if(k == 1 || k == n){
            return dp[n][k] = 1;
        }

        if(dp[n][k]!=0) return dp[n][k];

        int ownSet = count_of_ways(n-1,k-1,dp);
        int partOfSet = count_of_ways(n-1,k,dp) * k;

        return dp[n][k] = ownSet + partOfSet;
    }

    public static void count_of_ways(){

    }

    //StringSet.================================================================

    //longest Plaindromic Subsequence
    // 516
    public static int longestPSS(String str,int i ,int j,int[][] dp){
        if(i >= j){
            return dp[i][j] = (i == j ? 1 : 0);
        }

        if(dp[i][j] != 0) return dp[i][j];

        if(str.charAt(i) == str.charAt(j)) return dp[i][j] = longestPSS(str,i+1,j-1,dp) + 2;
        else return dp[i][j] = Math.max(longestPSS(str,i+1,j,dp),longestPSS(str,i,j-1,dp));
    }

    public static int longestPSS_DP(String str,int i ,int j,int[][] dp){
        int n = str.length();
        for(int gap = 0;gap < n;gap++){
            for(i=0,j=gap;j<n;i++,j++){
                if(i == j) dp[i][j] = 1;
                else if(str.charAt(i) == str.charAt(j)) dp[i][j] = dp[i+1][j-1] + 2;
                else dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]);
            }
        }
    
          return dp[0][n-1];
    }
    

    public static void longestPSS_String(String str,int i ,int j,int[][] dp,char[] ans,int si,int ei){
        if(i >= j){
            if(i == j) {   
                ans[si] = str.charAt(i);
                for(char ch : ans) System.out.print(ch);
                System.out.println();
            }

            return;
        }
       
        if(str.charAt(i) == str.charAt(j)){
            ans[si] = ans[ei] = str.charAt(i);
            longestPSS_String(str,i+1,j-1,dp,ans,si+1,ei-1);
        }else if(dp[i+1][j] > dp[i][j-1]){
            longestPSS_String(str,i+1,j,dp,ans,si,ei);
        }else{
            longestPSS_String(str,i,j-1,dp,ans,si,ei);
        }
    }

    public static int lCSS(String s1,String s2,int i,int j,int[][] dp){
        if(i == s1.length() || j == s2.length()){
            return dp[i][j] = 0;
        }

        if(dp[i][j] != 0) return dp[i][j];

        if(s1.charAt(i) == s2.charAt(j)) return dp[i][j] = lCSS(s1,s2,i+1,j+1,dp) + 1;
        else return dp[i][j] = Math.max(lCSS(s1,s2,i+1,j,dp),lCSS(s1,s2,i,j+1,dp));        
    }

    public static int lCSS_02(String s1,String s2,int n,int m,int[][] dp){
        if(n == 0 || m == 0){
            return dp[i][j] = 0;
        }

        if(dp[i][j] != 0) return dp[i][j];

        if(s1.charAt(n-1) == s2.charAt(m-1)) return dp[i][j] = lCSS(s1,s2,m-1,,m-1,dp) + 1;
        else return dp[i][j] = Math.max(lCSS(s1,s2,n-1,j,dp),lCSS(s1,s2,i,m-1,dp));        
    }

    public static int lCSS_DP(String s1,String s2,int i,int j,int[][] dp){
        for(int i = s1.length() - 1; i >= 0; i--){
            for(int i = s2.length() - 1; j >= 0; j--){

                if(i == s1.length() || j == s2.length()){
                    dp[i][j] = 0;
                    continue;
                }
                
                if(s1.charAt(i) == s2.charAt(j)) dp[i][j] = dp[i+1][j+1] + 1;
                else dp[i][j] = Math.max(dp[i+1][j],dp[i][j+1]);        
            }
        }

        return dp[0][0];
    }


    //https://priactice.geeksforgeeks.org/problems/count-palindromic-subsequences/1

    public static int countPS(String str,int i,int j,int[][] dp)
    {
        if(i>=j){
            return dp[i][j] = ( i == j ) ? 1 : 0;
        }

        int x = countPS(str,i+1,j-1,dp);
        int y = countPS(str,i,j-1,dp);
        int z = countPS(str,i+1,j,dp);
        
        if(str.charAt(i) == str.charAt(j)) dp[i][j] = (x + 1) + (y + z - x);
        else dp[i][j] = (y + z - x);

        return dp[i][j];
    }

    public static int countPS(String str)
    {
        int n = str.length();
        int[][] dp = new int[n][n];

        System.out.println(countPS(str, 0, 0 , dp));
    }

    // Leetcode 115 - Distinct Subsequences
    public static int numDistinct(String s, String t,int n,int m , int[][] dp) {
        if(n < m){
            return dp[n][m] = 0;
        }

        if(m==0){
            return dp[n][m] = 1;
        }

        if(dp[n][m] != -1) return dp[n][m];

        int a = numDistinct(s,t,n-1,m-1,dp);
        int b = numDistinct(s,t,n-1,m,dp);

        if(s.charAt(n-1) == t.charAt(m-1)) dp[n][m] = a + b;
        else dp[n][m] = b;

        return dp[n][m];
    }


    public static int numDistinct(String s, String t) {
        int n = s.length();
        int m = t.length();
        int[][] dp = new int[n + 1][m + 1];
        
        for (int[] d : dp)
            Arrays.fill(d, -1);
        
        int ans = numDistinct(s, n,t, m, dp);
        
        // for (int[] d : dp) {
        //     for (int ele : d) {
        //         System.out.print(ele + " ");
        //     }
        //     System.out.println();
        // }
        return ans;
    }

    //Leetcode 940
    public int distinctSubseqII(String S) {
        int n = S.length();
       if(n==0) return 0;
       
       int mod = (int)1e9 + 7;
       
       S = "$"+S;
       int[] dp = new int[n+1];
       int[] locc = new int[26];
       Arrays.fill(locc,-1);
       
       dp[0] = 1;
       for(int i = 1;i <= n; i++){
           char ch = S.charAt(i);
           
           dp[i] = (dp[i-1] * 2) % mod;
           if(locc[ch-'a']!=-1){
               dp[i] =(dp[i] % mod  - dp[locc[ch-'a'] - 1] % mod + mod) % mod;
           }
           
           locc[ch-'a'] = i;
       }
       
       return dp[n] - 1;   
   }

   // https://www.geeksforgeeks.org/number-subsequences-form-ai-bj-ck/
   public static void aibjck(String str){

      int aCount = 0;
      int bCount = 0;
      int cCount = 0;
      for(int i=0;i<str.length();i++){
        char ch = str.charAt(i);
        if(ch == 'a') aCount =  aCount + (1 + aCount);   // notInclude  + Include (prev + self)
        else if(ch == 'b') bCount = bCount  + (aCount + bCount) ; // notInclude  + Include (prev + self)
        else if(ch == 'c') cCount = cCount  + (bCount + cCount) ; // notInclude  + Include (prev + self)
      }

      return cCount;
   }
   
   //72
   int editDistance(String word1, String word2,int n,int m,int[][] dp) {
    if(n==0 || m==0){
        return n!=0?n:m;
    }
    
    if(dp[n][m]!=-1) return dp[n][m];
    
    if(word1.charAt(n-1)==word2.charAt(m-1)) return dp[n][m]=editDistance(word1,word2,n-1,m-1,dp);
    else{
        int insert_  = editDistance(word1,word2,n,m-1,dp);
        int delete_  = editDistance(word1,word2,n-1,m,dp);
        int replace_ =editDistance(word1,word2,n-1,m-1,dp);
        
        return dp[n][m]=Math.min(Math.min(insert_,replace_),delete_)+1;
    }
}

int editDistance_DP(String word1, String word2,int n,int m,int[][] dp) {
    int N = n, M = m;
    for(n = 0;n <= N;n++){
        for(m=0;m <= M;m++){
            if(n==0 || m==0){
                dp[n][m] = n!=0?n:m;
                continue;
            }
            
            if(word1.charAt(n-1)==word2.charAt(m-1)) dp[n][m]=dp[n-1][m-1];
            else{
                int insert_  = dp[n][m-1];
                int delete_  = dp[n-1][m];
                int replace_ = dp[n-1][m-1];
                
                dp[n][m]=Math.min(Math.min(insert_,replace_),delete_)+1;
            }
        }
    }
}

public int wildCardMatching(String str1,String str2,int n,int m,int[][] dp){
    if(n == 0 && m == 0) return dp[n][m] = 1;
    else if(n==0 || m == 0){
        if(m == 1 && str2.charAt(m-1)=='*') return dp[n][m] = 1;
        return dp[n][m] = 0;
     }
 
     if(dp[n][m]!=-1) return dp[n][m];
 
     char ch1 = str1.charAt(n-1);
     char ch2 = str2.charAt(m-1);
     int val = -1;
     if(ch1 == ch2 || ch2 == '?') val = wildCardMatching(str1,str2,n-1,m-1,dp);
     else if(ch2=='*'){
         boolean res = false;
         res  = res || wildCardMatching(str1,str2,n-1,m,dp) == 1;
         res = res || wildCardMatching(str1,str2,n,m-1,dp) == 1;
 
         val = res ? 1 : 0;
     }
     else val = 0;
 
 
     return dp[n][m] = val;
 
 }
 
 public String removeStar(String s){
     if(s.length()==0) return "";
     StringBuilder sb = new StringBuilder();
 
     sb.append(s.charAt(0));
     int i = 1;
     while(i<s.length()){
         while( i<s.length() && s.charAt(i) == '*' &&  s.charAt(i-1) == s.charAt(i)) i++;
         
         if(i<s.length())sb.append(s.charAt(i));
         i++;
     }
 
     return sb.toString();
 }
 
 public boolean isMatch(String s, String p) {	
     p = removeStar(p);
     // System.out.println(p);
     int n = s.length();
     int m = p.length();
     int[][] dp = new int[n+1][m+1];
     for(int[] a: dp) Arrays.fill(a,-1);
 
     return wildCardMatching(s,p,n,m,dp) == 1;
 }
 
int minDistance(String word1, String word2) {
    int[][] dp = new int[word1.length() + 1][word2.length() + 1];
    for (int[] d : dp)
        Arrays.fill(d, -1);
     return editDistance(word1,word2,word1.length(),word2.length(),dp);
}

 public int numDecodings(String s,int idx,int[] dp){
     if(idx >= s.length()){
         return dp[idx] = 1;
     }
     
     if(dp[idx] != 0) return dp[idx];
     
     
     char ch = s.charAt(idx);
     if(ch == '0') return 0;
     
     int count = 0;
     
     count += numDecodings(s,idx+1,dp);
     if(idx < s.length()-1){
         char ch1 = s.charAt(idx+1);
         int num = ( ch - '0') * 10 + (ch1 - '0');
         if(num <= 26){
             count += numDecodings(s,idx + 2,dp);
         }
     }
     
     return dp[idx] = count;
 }

 public int numDecodings_DP(String s,int idx,int[] dp){
    for(idx = s.length(); idx >= 0 ; idx--){
        if(idx >= s.length()){
            dp[idx] = 1;
            continue;
        }
        
        char ch = s.charAt(idx);
        if(ch == '0'){
            dp[idx] = 0;
            continue;
        }
        dp[idx] += dp[idx + 1];
        if(idx < s.length()-1){
            char ch1 = s.charAt(idx+1);
            int num = ( ch - '0') * 10 + (ch1 - '0');
            if(num <= 26){
                dp[idx] += dp[idx + 2];
            }
        }
    }

    return dp[0];
 }

 public int numDecodings_Opti(String s,int idx,int[] dp){
    int a = 1;
    int b = 0;
    for(idx = s.length()-1; idx >= 0 ; idx--){

        char ch = s.charAt(idx);
        int sum = 0;
        if(ch != '0'){
            sum += a;
            if(idx < s.length()-1){
                char ch1 = s.charAt(idx+1);
                int num = ( ch - '0') * 10 + (ch1 - '0');
                if(num >= 10 && num <= 26){
                    sum += b;
                }
            }
        }

        b = a;
        a = sum;
    }

    return a;
 }

 
 
public int numDecodings(String s) {
    if(s.length()==0) return 0;
     int[] dp = new int[s.length() + 1];
     
    int ans = numDecodings(s, 0,dp);

    for(int ele: dp) System.out.print(ele + " ");
    return ans;
 }
 

 // Leetcode 639
 long mod = (int) 1e9 + 7; 
 public long numDecodings(String s,int idx,long[] dp){
    if(idx >= s.length()){
        return dp[idx] = 1;
    }
    
    if(dp[idx] != 0) return dp[idx];
    
    
    char ch = s.charAt(idx);
    if(ch == '0') return 0;
    
    long count = 0;
    
    if(ch >= '1' && ch <= '9') count = (count % mod  + numDecodings(s,idx+1,dp) % mod ) % mod;
    else if(ch == '*') count = (count % mod  + 9 * numDecodings(s,idx+1,dp) % mod ) % mod;
    
    if(idx < s.length()-1){
        char ch1 = s.charAt(idx+1);
        if(ch !='*' && ch1 != '*'){
            int num = ( ch - '0') * 10 + (ch1 - '0');
            if(num <= 26){
                count = (count +  numDecodings(s,idx + 2,dp) % mod ) % mod;
            }
        }else if((ch >= '1' && ch <='2' && ch1 == '*')){
            if(ch == '1') count = (count % mod  + 9 * numDecodings(s,idx+2,dp) % mod ) % mod;
            if(ch == '2') count = (count % mod  + 6 * numDecodings(s,idx+2,dp) % mod ) % mod;
        }else if(ch == '*' && ch1 != '*'){
            if(ch1 >='0' && ch1 <= '6') count = (count % mod  + 2 * numDecodings(s,idx+2,dp) % mod ) % mod;
            if(ch1 >='7' && ch1 <= '9') count = (count % mod  + numDecodings(s,idx+2,dp) % mod ) % mod;
        }else if(ch == '*' && ch1 == '*') count = (count % mod  + 15 * numDecodings(s,idx+2,dp) % mod ) % mod;
    }
    
    return dp[idx] = count % mod;
}

public int numDecodings(String s) {
    if(s.length()==0) return 0;
    long[] dp = new long[s.length() + 1];
    
    return (int)numDecodings(s, 0,dp);
}

// TargetSet/ CoinChange.==========================================================


public static int coinChangePermutation(int[] arr,int tar){
    if(tar == 0){
        return dp[tar] = 1;
    }

    if(dp[tar] != 0) return dp[tar];

    int count = 0;
    for(int ele : arr){
        if(tar - ele >= 0)
          count += coinChangePermutation(arr,tar - ele); 
    }

    return dp[tar] = count;
}

public static int coinChangePermutation_DP(int[] arr,int tar){

    int Tar = tar;
    dp[0] = 1;
    for(tar = 1 ;tar <= Tar;tar++){   
        for(int ele : arr){
            if(tar - ele >= 0)
              dp[tar] += dp[tar - ele];
        }
    }

    return dp[Tar];
}

public static int coinChangeCombination_DP(int[] arr,int tar){
    int Tar = tar;
    dp[0] = 1;
    for(int ele : arr){
        for(tar = ele ;tar <= Tar;tar++){   
              dp[tar] += dp[tar - ele];
        }
    }

    return dp[Tar];
}


//Leetcode 322

public static int coinChange(int[] coins,int tar,int[] dp){
    if(tar == 0){
        return dp[tar] = 0;
    }
    
    if(dp[tar] != -1) return dp[tar];

    int minCoin = (int)1e9;
    for(int ele: coins){
        if(tar - ele >= 0){
            int ans = coinChange(coins,tar-ele,dp);
            if(ans != (int)1e9 && ans + 1 < minCoin) minCoin = ans + 1;
        }
    }

    return dp[tar] = minCoin;
}

public static int coinChange(int[] coins,int tar,int[] dp){
    int Tar = tar;
    dp[0] = 0;
    for(tar = 1; tar <= Tar; tar++){
        int minCoin = (int)1e9;
        for(int ele: coins){
            if(tar - ele >= 0){
              int ans = dp[tar - ele];
              if(ans != (int)1e9 && ans + 1 < minCoin) minCoin = ans + 1;
            }
        }

       dp[tar] = minCoin;
    }

    return dp[Tar];
}

public int coinChange(int[] coins, int amount) {
    int[] dp=new int[amount+1];
    Arrays.fill(dp,-1);
    int ans = coinChange(coins,amount,dp);
    
    return ans!=(int)1e9?ans:-1;
}

//https://www.geeksforgeeks.org/find-number-of-solutions-of-a-linear-equation-of-n-variables/
// same as coin change combination.

public static int targetSum(int[] arr,int idx,int tar,int[][] dp){
    if(tar == 0 || idx == arr.length){
        return dp[idx][tar] = (tar == 0)? 1 : 0;
    }

    if(dp[idx][tar]!=0) return dp[idx][tar];
    
    if(tar - arr[idx] >= 0) dp[idx][tar] += targetSum(arr,idx+1,tar-arr[idx],dp);
    dp[idx][tar] += targetSum(arr,idx+1,tar,dp); 

    return dp[idx][tar];
}

public static int targetSum(int[] arr,int n,int tar,int[][] dp){
    if(tar == 0 || n == 0){
        return dp[n][tar] = (tar == 0)? 1 : 0;
    }

    if(dp[n][tar]!=0) return dp[idx][tar];
    
    if(tar - arr[ n - 1] >= 0) dp[n][tar] += targetSum(arr,n - 1,tar - arr[n - 1],dp);
    dp[n][tar] += targetSum(arr,n - 1,tar,dp); 

    return dp[n][tar];
}

public static int targetSum(int[] arr,int N,int Tar,int[][] dp){
    for(int n = 0; n<=N;n++){
        for(int tar = 0 ; tar<=Tar;tar++){
            
            if(tar == 0 || n == 0){
                dp[n][tar] = (tar == 0)? 1 : 0;
                continue;
            }

            if(tar - arr[ n - 1] >= 0) dp[n][tar] += dp[n-1][tar];
            dp[n][tar] += dp[n-1][tar];             
        }
    }

    return dp[N][Tar];
}

// 494
public int findTargetSumWays(int[] nums,int n,int sum, int tar,int[][] dp) {
    if(n==0){
        return dp[n][sum] = ( tar == sum ) ? 1: 0;
        
    }
    
    if(dp[n][sum] != -1) return dp[n][sum];
    
    int count = 0;
    count += findTargetSumWays(nums,n - 1,sum - nums[n-1],tar,dp);    // num is positive
    count += findTargetSumWays(nums,n - 1,sum + nums[n-1],tar,dp);   // num is negative
    
    return dp[n][sum] = count;
    
}
   
 public int findTargetSumWays_DP(int[] nums,int N,int Sum, int tar,int[][] dp) {
     
     dp[0][0 + Sum] = 1;
     for(int n = 1; n <= N;n++){
         for(int sum = 0 ; sum  <= 2*Sum;sum++) {
    
            int count = 0;
            if(sum-nums[n-1] >=0 )count += dp[n-1][sum-nums[n-1]] ;
            if(sum + nums[n-1] <= 2*Sum )count += dp[n-1][sum+nums[n-1]] ;
            
             dp[n][sum] = count;
         }
     }
     
     return dp[N][tar];
}
   
public int findTargetSumWays(int[] nums, int tar) {
    int n = nums.length;
    if(n == 0) return 0;
    
    int sum = 0;
    for(int ele: nums) sum += ele;
    
    if(tar > sum || tar < -sum) return 0;
    
    int[][] dp = new int[n+1][2 * sum + 1];
    
    // for(int[] a: dp) Arrays.fill(a,-1)
    // int ans = findTargetSumWays(nums,n,sum,tar + sum,dp);
    
    int ans = findTargetSumWays_DP(nums,n,sum,tar + sum,dp);
    
    return ans;
}


// Leetcode 416
public boolean canPartition(int[] nums) {
    int N = nums.length;
    if(N==0) return false;

    int sum = 0;
    for(int ele : nums) sum += ele;
    if(sum%2 != 0) return false;

    int Tar = sum/2;
    boolean[][] dp = new boolean[N+1][Tar + 1];
    
    for(int n = 0 ; n <= N;n++){
        for(int tar = 0 ; tar <= Tar;tar++){
            if(n==0 || tar == 0){
                dp[n][tar] = (tar == 0) ? true: false;
                continue;
            }

            if(tar - nums[n-1] >= 0)
               dp[n][tar] = dp[n][tar] || dp[n-1][tar - nums[n-1]];
            dp[n][tar] = dp[n][tar] || dp[n-1][tar];
        }
    }

    return dp[N][Tar];
}

public static int knapSack01(int[] weight,int[] price,int n,int cap,int[][] dp){
    if(n == 0 || cap == 0){
        return dp[n][cap] = 0;
    }
    
    if(dp[n][cap] != -1) return dp[n][cap];
    
    int maxVal = 0;
    if(cap - weight[n-1] >=0 ) maxVal = Math.max(maxVal, knapSack01(weight,price,n-1,cap-weight[n-1],dp) + price[n-1]);
    maxVal = Math.max(maxVal, knapSack01(weight,price,n-1,cap,dp)); 

    return dp[n][cap] = maxVal;
}

public static void knapSack(int[] weight,int[] value,int cap){
    int n = weight.length;
    int[][] dp = new int[n+1][cap+1];
    for(int[] d: dp) Arrays.fill(d,-1);
    
    int ans = knapSack01(weight,value,n,cap,dp);
}

//https://practice.geeksforgeeks.org/problems/knapsack-with-duplicate-items4201/1
public static int knapSack_unbounded(int N, int W, int val[], int wt[],int[][] dp){
    if(N==0 || W==0){
        return dp[N][W] = 0;
    }
    
    if(dp[N][W]!= -1) return dp[N][W];
    
    int maxVal = 0;
    if(W-wt[N-1]>=0) maxVal = Math.max(maxVal,knapSack_unbounded(N,W-wt[N-1],val,wt,dp) + val[N-1]);
    maxVal = Math.max(maxVal,knapSack_unbounded(N-1,W,val,wt,dp));
    
    return dp[N][W] = maxVal;
    
}

public static int knapSack_unbounded(int N, int W, int val[], int wt[],int[][] dp){
    dp[0] = 0;
    for(int i = 0;i<N;i++){
        for(int w = wt[i]; w <= W;w++){
            dp[w] = Math.max(dp[w],dp[w-wt[i]] + val[i]);
        }
    }

    return dp[W];
}

static int knapSack(int N, int W, int val[], int wt[])
{
    int[][] dp = new int[N+1][W+1];
    for(int[] d: dp) Arrays.fill(d,-1);
    
    return knapSack_unbounded(N,W,val,wt,dp);
}











    public static void stringSet(){
        // String str = "geeksforgeeks";
        // int n = str.length();
        // int[][] dp = new int[n][n];
        
        // for(int[] d:dp) Arrays.fill(d,-1);

        // System.out.println(longestPSS(str,0,str.length()-1,dp));
        // System.out.println(longestPSS_DP(str,0,str.length()-1,dp));

        // int len = dp[0][n-1];
        // char[] ans = new char[len];
        // longestPSS_String(str,0,n-1,dp,ans,0,len-1);
        
        //---------------------------------------------------------------------------

        String s1 = "AGGTAB";
        String s2 = "GXTXAYB";
        
        int n = s1.length();
        int m = s2.length();
        int[][] dp = new int[n+1][m+1];
        System.out.println(lCSS_DP(s1,s2,0,0,dp));

        print2D(dp);
    }

    public static void Basic(){
        // int n = 10;
        // int[] dp = new int[n+1];

        
        // int n=5;
        // int[][] dp =new int[n][n];
        // System.out.println(mazePath_HVD(0,0,n-1,n-1,dp));
        // System.out.println(mazePath_HVD_DP(0,0,n-1,n-1,dp));

        // System.out.println(mazePath_HVDJump_DP(0,0,n-1,n-1,dp));
           
        // int n = 10;
        // int[] dp = new int[n+1];
        // System.out.println(boardPath(0,n,dp));
        // System.out.println(boardPath_DP(0,n,dp));
        
        // System.out.println(goldMineProblem());
        // frindsPairing();

        // print(dp);
        // print2D(dp);
    }


    public static void solve(){
        // Basic();
        stringSet();
    }

    public static void main(String[] args){
        solve();
    }
}

public class l002{
    
  



    // https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-dp-14/
    public static int maxSumIS(int arr[], int n)  
	{  
        int n = arr.length;
	    int sum = 0;
	    int[] dp = new int[n];
	    for(int i = 0;i<n;i++){
	        dp[i] = arr[i];
	        for(int j = i - 1;j>=0 ; j--){
	            if(arr[i] > arr[j]){
	                dp[i] = Math.max(dp[i] , dp[j] + arr[i]);
	            }
	        }
	        
	        sum = Math.max(sum,dp[i]);
	    }
	    return sum;
	}  

    public static int minNoOFDeletion(int[] arr){
        int n = arr.length();
        int[] dp = new int[n];

        int len = 0;
        for(int i = 0; i < n; i++ ){   
            dp[i] = 1;
            for(int j = i-1;j>=0;j--){
               if(arr[j] >= arr[i]){
                  dp[i] = Math.max(dp[i],dp[j] + 1);
               }
            }

            len = Math.max(len,dp[i]);
        }

        return n - len;
    }

    //Leetcode 673
    public int findNumberOfLIS(int[] arr) {
        int n=arr.length;
        int[] dp=new int[n];
        int[] count=new int[n];

        int maxLen=0;
        int maxCount=0;

        for(int i = 0; i < n; i++){
            
            dp[i] = 1;
            count[i] = 1;

            for(int j = i-1; j>=0; j--){
                if(arr[i] > arr[j]){

                    if(dp[j] + 1 > dp[i]){
                        dp[i] = dp[j] + 1;
                        count[i] = count[j];
                    }else if(dp[j] + 1 == dp[i]){
                        count[i] += count[j]; 
                    }
                }
            }

            if(dp[i] > maxLen){
                maxLen = dp[i];
                maxCount = count[i];
            }else if(dp[i] == maxLen){
                maxCount += count[i];
            }
        }

        return maxCount;
    }

    // 354
    public static int maxEnvelopes(int[][] arr) {
        if(arr.length==0) return 0;
        
        int n = arr.length;
        Arrays.sort(arr,(a,b)->{
            if(a[0] == b[0]) return b[1] - a[1];
            return a[0] - b[0];  // this - other, Increasing Order
        });

        int[] dp = new int[n];
        int maxLen = 0;
        for(int i = 0;i<n;i++){
            dp[i] = 1;
            for(int j = i - 1;j>=0;j--){
                if(arr[i][1] > arr[j][1]){
                    dp[i] = Math.max(dp[i],dp[j] + 1);
                }
            }

            maxLen = Math.max(maxLen,dp[i]);
        }
        return maxLen;
    }

    //413
    public int numberOfArithmeticSlices(int[] A) {
        if(A.length < 3) return 0;
        
        int ans = 0;
        int count = 0;
        
        for(int i = 1; i < arr.length - 1; i++){
            
            int d1 = arr[i] - arr[i-1];
            int d2 = arr[i+1] - arr[i];
            
            if(d1 == d2) ans += (++count);
            else count = 0;
        }
        
        return ans;  
    }
    
    //1218
    public int longestSubsequence(int[] arr, int d) {
        HashMap<Integer,Integer> map = new HashMap<>();
        
        int maxLen = 0;
        for(int ele : arr){
            map.put(ele,map.getOrDefault(ele-d,0) + 1);
            maxLen = Math.max(map.get(ele),maxLen);
        }
        
        return maxLen;   
    }

    //1027
    public int longestArithSeqLength(int[] A) { 
        int n = A.length;
        HashMap<Integer,Integer>[] dp = new HashMap[n];
        
        int len = 0;
        for(int i = 0;i<n;i++) dp[i] = new HashMap<Integer,Integer>();
        
        for(int i = 0; i < n; i++){    
            for(int j = i - 1; j >= 0; j--){
                int diff = A[i] - A[j];
                
                int currLen = dp[i].getOrDefault(diff,0);
                int newLen = dp[j].getOrDefault(diff,1) + 1;
                
                dp[i].put(diff,Math.max(currLen,newLen));
                
                len = Math.max(len,dp[i].get(diff));
            }
        }
        
        return len;
    }

    //for You ----> Leetcode 446

    // https://www.geeksforgeeks.org/longest-alternating-subsequence/?ref=rp
    public static int longestAlternatingSubsequence(int[] arr){

        int n = arr.length;
        int[][] dp = new int[n][2];  // (decreasing slope, increasing slope)

        int maxLen = 0;
        for(int i = 0; i < n; i++){
            dp[i][0] = dp[i][1] = 1;
            for(int j = i-1; j >= 0 ; j--){   
                if(arr[i] > arr[j]) dp[i][1] = Math.max(dp[i][1],dp[j][0] + 1);
                if(arr[i] < arr[j]) dp[i][0] = Math.max(dp[i][0],dp[j][1] + 1);
            }

            maxLen = Math.max(maxLen, Math.max(dp[i][0],dp[i][1]));
        }

        return maxLen;
    }

    //For you --> https://www.geeksforgeeks.org/maximum-sum-alternating-subsequence-sum/
    public static int BuildingBridges(int[][] arr){
        int n = arr.length;
        Arrays.sort(arr,(a,b)->{
            // if(a[0] == b[0]) return b[1] - a[1];
            return a[0] - b[0];
        });
        
        int[] dp = new int[n];
        int len = 0;

        for(int i=0;i<n;i++){
            for(int j = i-1;j>=0;j--){
                if(arr[i][1] > arr[j][1]){
                    dp[i] = Math.max(dp[i],dp[j]+1);
                }
            }

            len = Math.max(len,dp[i]);
        }

        return len;
    }



    public static void LISset(){

        int[] arr = {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15,10};
        System.out.println(LIS_rec(arr));
    }

       public static void solve(){
           LISset();
       }


       public static void main(String[] args){
           solve();
       }
    
}

import java.util.Arrays;
public class l003_CutType{

    public static void print(int[] arr){
        for(int ele: arr)
        System.out.print(ele+" ");

        System.out.println();
    }

    public static void print2D(int[][] arr){
        for(int[] ar: arr) print(ar);
        System.out.println();
    }

    public static int mcm_rec(int[] arr,int si,int ei,int[][] dp){
        if(si + 1 == ei){
            return dp[si][ei] = 0;
        }

        if(dp[si][ei]!=0) return dp[si][ei];

        int myAns = (int)1e8;
        for(int cut = si + 1;cut<ei;cut++){
            int leftTree = mcm_rec(arr,si,cut,dp);
            int rightTree = mcm_rec(arr,cut,ei,dp);

            int myCost = leftTree +  arr[si] * arr[cut] * arr[ei] + rightTree;
            
            myAns = Math.min(myAns, myCost);
        }

        return dp[si][ei] = myAns;
    }

    public static int mcm_DP(int[] arr,int SI,int EI,int[][] dp){
        int n = arr.length;
        for(int gap = 1; gap < n;gap++){
            for(int si = 0, ei = gap; ei < n; si++,ei++){
                if(si + 1 == ei){
                    dp[si][ei] = 0;
                    continue;
                }
        
                int myAns = (int)1e8;
                for(int cut = si + 1;cut<ei;cut++){
                    int leftTree = dp[si][cut];
                    int rightTree = dp[cut][ei];
        
                    int myCost = leftTree +  arr[si] * arr[cut] * arr[ei] + rightTree;
                    
                    myAns = Math.min(myAns, myCost);
                }
        
                dp[si][ei] = myAns;
            }
        }

        return dp[SI][EI];
    }

    public static int mcm_DPString(int[] arr,int SI,int EI,int[][] dp){
        int n = arr.length;
        String[][] sdp = new String[n][n];

        for(int gap = 1; gap < n;gap++){
            for(int si = 0, ei = gap; ei < n; si++,ei++){
                if(si + 1 == ei){
                    String s = ""+(char)(si + 'A');
                    sdp[si][ei] = s;
                    dp[si][ei] = 0;
                    continue;
                }
        
                int myAns = (int)1e8;
                String s = "";
                for(int cut = si + 1;cut<ei;cut++){
                    int leftTree = dp[si][cut];
                    int rightTree = dp[cut][ei];
        
                    int myCost = leftTree +  arr[si] * arr[cut] * arr[ei] + rightTree;
                    
                    if(myCost < myAns){
                        myAns = myCost;
                        s = "("  + sdp[si][cut] + sdp[cut][ei] + ")";
                    }
                }
        
                dp[si][ei] = myAns;
                sdp[si][ei] = s;
            }
        }

        System.out.println(sdp[SI][EI]);
        return dp[SI][EI];
    }


    public static void mcm(){
        int[] arr = {4, 2, 3, 1, 3};
        int n = arr.length;

        int[][] dp = new int[n][n];
        System.out.println(mcm_DPString(arr,0,n-1,dp));

        print2D(dp);
    }

    //https://www.geeksforgeeks.org/minimum-maximum-values-expression/

    public static class minMaxPair{
        int minVal = (int) 1e8;
        int maxVal = 0;

        minMaxPair(int minVal,int maxVal){
            this.minVal = minVal;
            this.maxVal = maxVal;
        }

        minMaxPair(){

        }

        public String toString(){
            return "(" + this.minVal + ", " + this.maxVal +  ")";
        }
    }

    
    public static int evaluate(char ch,int v1, int v2){
        if(ch == '+') return v1 + v2;
        else if(ch == '+') return v1 - v2;    
        else return v1 * v2;
    }

    public static minMaxPair minMaxValue(String str,int si,int ei,minMaxPair[][] dp){
        if(si == ei){
            int val = str.charAt(si) - '0';
            return dp[si][ei] = new minMaxPair(val,val);
        }

        if(dp[si][ei] != null) return dp[si][ei];
        
        
        minMaxPair myAns = new minMaxPair();

        for(int cut = si + 1; cut < ei; cut+=2){
            minMaxPair leftTree = minMaxValue(str,si , cut - 1,dp);
            minMaxPair rightTree = minMaxValue(str,cut + 1, ei,dp);

            
            char ch = str.charAt(cut);
            myAns.minVal = Math.min(myAns.minVal,evaluate(ch,leftTree.minVal,rightTree.minVal));
            myAns.maxVal = Math.max(myAns.maxVal,evaluate(ch,leftTree.maxVal,rightTree.maxVal));
        }

        return dp[si][ei] = myAns;
    }

    public static minMaxPair minMaxValue_DP(String str,int SI,int EI,minMaxPair[][] dp){
        int n = str.length();
        for(int gap = 0 ; gap < n; gap++){
            for(int si = 0, ei = gap; ei < n ; si++,ei++){
                if(si == ei){
                    int val = str.charAt(si) - '0';
                    dp[si][ei] = new minMaxPair(val,val);
                    continue;
                }
                
                minMaxPair myAns = new minMaxPair();
        
                for(int cut = si + 1; cut < ei; cut+=2){
                    minMaxPair leftTree = dp[si][cut-1];//minMaxValue(str,si , cut - 1,dp);
                    minMaxPair rightTree = dp[cut+1][ei];//minMaxValue(str,cut + 1, ei,dp);
        
                    
                    char ch = str.charAt(cut);
                    myAns.minVal = Math.min(myAns.minVal,evaluate(ch,leftTree.minVal,rightTree.minVal));
                    myAns.maxVal = Math.max(myAns.maxVal,evaluate(ch,leftTree.maxVal,rightTree.maxVal));
                }
        
                dp[si][ei] = myAns;
            }
        }

        return dp[SI][EI];
    }

    public static minMaxPair evalCombination(char operator,minMaxPair p1,minMaxPair p2){

        int a = evaluate(operator,p1.minVal,p2.minVal);
        int b = evaluate(operator,p1.minVal,p2.maxVal);
        int c = evaluate(operator,p1.maxVal,p2.minVal);
        int d = evaluate(operator,p1.maxVal,p2.maxVal);

        minMaxPair p = new minMaxPair();
        p.minVal = Math.min(Math.min(a,b),Math.min(c,d));
        p.maxVal = Math.max(Math.max(a,b),Math.max(c,d));

        return p;
    }

    public static minMaxPair minMaxValue_02(int[] numArr,char[] chArr,int si,int ei,minMaxPair[][] dp){
        if(si == ei){
            int val = numArr[si];
            return dp[si][ei] = new minMaxPair(val,val);
        }

        if(dp[si][ei] != null) return dp[si][ei];
        
        minMaxPair myAns = new minMaxPair();

        for(int cut = si; cut < ei; cut++){
            minMaxPair leftTree = minMaxValue_02(numArr,chArr,si , cut,dp);
            minMaxPair rightTree = minMaxValue_02(numArr,chArr,cut + 1, ei,dp);

            char operator = chArr[cut];
            minMaxPair p = evalCombination(operator,leftTree,rightTree);

            myAns.minVal = Math.min(myAns.minVal, p.minVal);
            myAns.maxVal = Math.max(myAns.maxVal, p.maxVal);
        }

        return dp[si][ei] = myAns;        
    }



    public static void minMaxValue(){
        String str = "1+2*3+4*5+2*3+3+3+3*3*8*7";

        int n = str.length();
        minMaxPair[][] dp = new minMaxPair[n][n];
        minMaxPair ans = minMaxValue(str,0,n-1,dp);

        System.out.println(ans.minVal + " , " + ans.maxVal);

        for(minMaxPair[] d : dp){
            for(minMaxPair e: d){
                System.out.print(e);
            }
            System.out.println();
        }
    }

    // Leetcode 312
    public int maxCoins(int[] nums,int si,int ei ,int[][] dp) {
        if(dp[si][ei] != -1) return dp[si][ei];
        
        int liVal = (si - 1 == -1) ? 1 : nums[si - 1];
        int riVal = (ei + 1 == nums.length) ? 1 : nums[ei + 1];
        
        int myCost = 0;
        
        for(int cut = si;cut<=ei;cut++){
            int leftTree = (cut == si)?0:maxCoins(nums,si,cut-1,dp);
            int rightTree = (cut == ei)?0:maxCoins(nums,cut+1,ei,dp);
            
            myCost = Math.max(myCost, leftTree + liVal * nums[cut] * riVal + rightTree); 
        }
        
        return dp[si][ei] = myCost;
    }
    
    public int maxCoins(int[] nums) {
        int n = nums.length;
        if(n == 0) return 0;
        
        int[][] dp = new int[n][n];
        for(int[] d: dp)Arrays.fill(d,-1);
        
        return maxCoins(nums,0,n-1,dp);
        
    }

    public static int OBST(int[] freq,int si,int ei,int[][] dp,int[] prefixSum){
        if(dp[si][ei]!=0) return dp[si][ei];

        int myRes = (int) 1e8;
        // int sum = 0;
        for(int cut = si; cut<=ei;cut++){
            int leftTree = cut == si ? 0 : OBST(freq,si,cut-1,dp,prefixSum);
            int rightTree = cut == ei ? 0 : OBST(freq,cut + 1,ei,dp,prefixSum);

            int myAns = leftTree +  (prefixSum[ei] - (si == 0 ? 0 : prefixSum[si-1]))  + rightTree;  
            // int myAns = leftTree + rightTree;
            
            myRes = Math.min(myRes,myAns);
            
            // sum+=freq[cut];
        }

        return dp[si][ei] = myRes;
    }

    public static void OBST(){
        int[] freq = {34, 8, 50};
        int[] val = {10, 12, 20};

        int n = val.length;

        int[][] dp = new int[n][n];

        int[] prefixSum = new int[n];
        
        int prev = 0;
        for(int i = 0;i<n;i++){
            prefixSum[i] = prev + freq[i];
            prev = prefixSum[i];
        }

        System.out.println(OBST(freq,0,n-1,dp,prefixSum));
        print2D(dp);
    }

    // 1039
    public int minTriangulation(int[] A,int si,int ei,int[][] dp){
        if(ei - si < 2) return dp[ei][si] = 0;
        if(dp[ei][si] != -1 ) return dp[si][ei];

        int minAns = (int) 1e8;
        for(int cut = si + 1; cut < ei; cut++){
            int leftTree = minTriangulation(A,si,cut,dp);
            int rightTree = minTriangulation(A,cut,ei,dp);

            int myAns = leftTree + arr[si] * arr[cut] * arr[ei] + rightTree;
            minAns = Math.min(minAns,myAns);
        }

        return dp[si][ei] = minAns;
    }

    public int minScoreTriangulation(int[] A) {
        int n = A.length;
        int[][] dp = new int[n][n];
        for(int[] d: dp) Arrays.fill(d,-1);
        return minTriangulation(A,0,n-1,dp); 
    }

       //Leetcode 132
       public static int minCut_01(String str,int si,int ei ,int[][] dp,boolean[][] isPalindrome){
        if(isPalindrome[si][ei]) return 0;

        if(dp[si][ei] != -1) return dp[si][ei];

        int minAns = (int) 1e8;
        for(int cut = si; cut < ei;cut++){
            int leftTree = minCut_01(str,si,cut,dp,isPalindrome);
            int rightTree = minCut_01(str,cut + 1,ei,dp,isPalindrome);

            minAns = Math.min(minAns,leftTree + 1 + rightTree);
        }

        return dp[si][ei] = minAns;
    }

    public static int minCut_02(String str,int si,int ei ,int[] dp,boolean[][] isPalindrome){
        if(isPalindrome[si][ei]) return dp[si] = 0;
        if(dp[si] != -1 ) return dp[si];

        int minAns = (int) 1e8;
        for(int cut = si; cut<=ei;cut++){
            if(isPalindrome[si][cut]){
                minAns = Math.min(minAns, minCut_02(str,cut+1,ei,dp,isPalindrome) + 1);
            }
        }

        return dp[si] = minAns;
    }
    
    public static int minCut_02DP(String str,int SI,int EI ,int[] dp,boolean[][] isPalindrome){
        for(int si = EI;si>=0;si--){
            if(isPalindrome[si][EI]){
                dp[si] = 0;
                continue;
            }

            int minAns = (int) 1e8;
            for(int cut = si; cut<=EI;cut++){
                if(isPalindrome[si][cut]){
                    minAns = Math.min(minAns, dp[cut+1] + 1);
                }
            }
    
            dp[si] = minAns;                
        }

        return dp[SI];
    }
    
    
    public static int minCut(String str) {
        int n = str.length();
        // int[][] dp = new int[n][n];
        // for(int[] d: dp) Arrays.fill(d,-1);

        boolean[][] isPalindrome = new boolean[n][n];
        for(int gap = 0 ; gap < n ;gap++){
            for(int i = 0, j = gap; j<n;i++,j++){
                if(gap == 0) isPalindrome[i][j] = true;
                else if(gap == 1) isPalindrome[i][j] = str.charAt(i) == str.charAt(j);
                else isPalindrome[i][j] = str.charAt(i) == str.charAt(j) && isPalindrome[i + 1][j - 1];
            }
        }


        // int ans = minCut_01(str,0,n-1,dp, isPalindrome);

        int[] dp = new int[n];
        Arrays.fill(dp,-1);
        int ans = minCut_02DP(str,0,n-1,dp, isPalindrome);
        
        // for(int ele : dp) System.out.print(ele + " ");
        return ans;
    }
    
    //Leetcode 45
    public int jump(int[] nums,int idx,int[] dp) {
        if(idx == nums.length - 1){
            return dp[idx] = 0;    
        }
        
        if(dp[idx] != -1) return dp[idx];
        
        if(nums[idx] == 0){
            return dp[idx] = (int)1e8;
        }
        
        int minSteps = (int) 1e8;
        for(int jump = 1; idx + jump < nums.length && jump <= nums[idx]; jump++){
            int recAns = jump(nums,idx + jump,dp);
            
            if(recAns != (int)1e8){
                minSteps = Math.min(minSteps, recAns + 1);
            }
        }
        
        return dp[idx] = minSteps;
    
    }
    
    public int jump(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp,-1);
        
        int ans = jump(nums,0,dp);
        
        return ans;
        
    }

    public int jump(int[] nums) {
        int n = nums.length;

        int maxEnding = 0;
        int maxPossibleJump = 0;
        int jump = 0;
        for(int i=0;i<n;i++){

            maxPossibleJump = Math.max(maxPossibleJump, i + nums[i]);
            if(i == maxEnding){
                maxEnding = maxPossibleJump;
                jump++;
            }
        }

        return jump;
    }

    
    static int mod = 1003;
    public static void evaluate (int[] left,int[] right,char ch , int[] ans){ 
        int tleft = (left[0] % mod + left[1] % mod) % mod;
        int tright = (right[0]% mod + right[1]% mod)% mod;
        
        int tTF = ((tleft % mod) * (tright% mod ))% mod;
        
        if(ch == '|'){
            
            ans[0] += (tTF % mod - (left[1]% mod) * (right[1])% mod + mod) % mod;
            ans[1] += ((left[1]% mod) * (right[1])% mod) % mod;
        
            
        }else if(ch == '&'){
            
            ans[0] += ((left[0]% mod) * (right[0])% mod) % mod;
            ans[1] += (tTF % mod - (left[0]% mod) * (right[0])% mod + mod) % mod;
        }else{
            
            ans[0] += ( ((left[0]% mod) * (right[1])% mod) % mod + ((left[1]% mod) * (right[0])% mod) % mod)
                      %mod;
            ans[1] += ( ((left[0]% mod) * (right[0])% mod) % mod + ((left[1]% mod) * (right[1])% mod) % mod)
                      %mod;           
        }
        
        ans[0] %= mod;
        ans[1] %= mod;
    }
    
    
    
    // 0 th - > true, 1st -> false.
    public static int[] booleanParenthesization(String str,int si,int ei,int[][][] dp){
        if(si == ei){
            int[] base = new int[2];
            base[0] = str.charAt(si) == 'T' ? 1 : 0;
            base[1] = str.charAt(si) == 'F' ? 1 : 0;
            
            return base;
        }
        
        if(dp[si][ei][0] != 0 || dp[si][ei][1] != 0) return dp[si][ei];
        
        for(int cut = si + 1; cut < ei; cut += 2){
            
            int[] left = booleanParenthesization(str,si,cut-1,dp);
            int[] right = booleanParenthesization(str,cut + 1,ei,dp);
            
            char ch = str.charAt(cut);
            evaluate(left,right,ch,dp[si][ei]);
    }
    
        return dp[si][ei];
    }

    // Leetcode 1278
    public int palindromePartition(String s,int k,int si,int ei,int[][] dp,int[][] pdp){
        if(k >= (ei-si+1)){
            return dp[k][ei] = (k == (ei-si+1))?0:(int)1e8;
        }
        
        if(k == 1 || si  == ei){
            return dp[k][ei] = ( si == ei ) ? 0 : pdp[0][ei];
        }
        
        if(dp[k][ei] != -1) return dp[k][ei];
        
        int ans = (int)1e8;
        for(int cut = si; cut < ei;cut++){
            int recAns = palindromePartition(s,k-1,si,cut,dp,pdp);
            
            if(recAns!=(int)1e8)
            ans = Math.min(ans,recAns + pdp[cut+1][ei]);
        }
        
        return dp[k][ei] =  ans;
    }
    
    
    public int palindromePartition(String s, int k) {
        int n = s.length();
        if(k==0 || k == n ) return 0;
        
        int[][] dp = new int[k+1][n+1];
        for(int[] d:dp) Arrays.fill(d,-1);
        int[][] pdp = new int[n][n];
        
        for(int gap = 1 ;gap <n;gap++){
            for(int i =0,j=gap;j<n;i++,j++){
                pdp[i][j] += pdp[i+1][j-1];
                if(s.charAt(i) != s.charAt(j)) pdp[i][j] += 1;
            }
        }
        
        
        int ans = palindromePartition(s,k,0,n-1,dp,pdp);
        return ans; 
    }


    // Leetcode 1216
    public boolean isValidPalindrome(String s, int k) {
        int n = s.length();
        int[][] dp = new int[n][n];
        for(int gap = 0 ;gap <n;gap++){
            for(int i =0,j=gap;j<n;i++,j++){
                if(gap ==0) dp[i][j] = 1;
                else if(gap == 1 && s.charAt(i) == s.charAt(j)) dp[i][j] = 2;
                else if(s.charAt(i) == s.charAt(j)) dp[i][j] = dp[i+1][j-1] + 2;
                else dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]);    
            }
        }
        return n - dp[0][n-1] <= k;   
    }

    //688
    int dx[] = { -2, -1, 1, 2, -2, -1, 1, 2 }; 
    int dy[] = { -1, -2, -2, -1, 1, 2, 2, 1 }; 
    
    public double knightProbability(int N, int K, int r, int c,double[][][] dp ) {
        if(K == 0) dp[K][r][c] = 1;
        
        if(dp[K][r][c] != 0.0) return dp[K][r][c];
        
        double count = 0.0;
        for(int d = 0;d<8;d++){
            int x = r + dx[d];
            int y = c + dy[d];
            
            if(x>=0 && y>=0 && x<N && y<N){
                count += knightProbability(N,K-1,x,y,dp);
            }
        }
        
        return dp[K][r][c] = count/8.0;
    }
    
    
    public double knightProbability(int N, int K, int r, int c) {
        double[][][] dp = new double[K+1][N+1][N+1];
        return knightProbability(N,K,r,c,dp);
    }



    public static void solve(){
        // mcm();
        // minMaxValue();
        OBST();
    }

    public static void main(String[] args){
        solve();
    }
}

public class l004CatlaNumber{

    public static int ncr(int n,int r){  // O(min(r,n-r));
        if(r > n - r)
            r = n- r;
        
        long res = 0;
        for(long i = 0 ; i < k;i++){
            res = res * (n - i);
            res = res / (i + 1);
        }

        return (int)res;
    }

    public static void NoOfBST(int n){  // O(min(r,n-r));
        int c = ncr(2n,n);
        System.out.println(c/(n+1));
    }

    public static void NoOFBST2(int n){ //O(n2)
        int[] dp = new int[n+1];
        dp[0] = dp[1] = 1;
        for(int i=2;i<n;i++){
            for(int j=i-1,k=0; j >=0 ; j--,k++){
                dp[i] += dp[j] * dp[k];
            }
        }
    }

    // https://en.wikipedia.org/wiki/Catalan_number#:~:text=1%2C%201%2C%202%2C%205,sequence%20A000108%20in%20the%20OEIS).

    //600
    public int findIntegers(int num) {
        if(num == 0) return 0;
        
        int[] dp = new int[32];
        dp[0] = 1;
        dp[1] = 2;
        for(int i = 2;i<32;i++) dp[i] = dp[i-1] + dp[i-2];
        
        int ans = 0;
        int bits = 31;
        boolean prevBit = false;
        while(bits>=0){
            if(( num & (1 << bits)) != 0){
                ans += dp[bits];
                if(prevBit) return ans;
                prevBit = true;
            }else prevBit = false;
            
            bits--;
        }
        
        return ans + 1;
    }






}


//256
public int minCost(int[][] costs) {
        
    if(costs.length == 0 || costs[0].length == 0) return 0;
    
    int n = costs.length;
    for(int i=1;i<n;i++){
        costs[i][0] += Math.min(costs[i-1][1],costs[i-1][2]);
        costs[i][1] += Math.min(costs[i-1][0],costs[i-1][2]);
        costs[i][2] += Math.min(costs[i-1][1],costs[i-1][0]);
    }
    
    return Math.min(Math.min(costs[n-1][0],costs[n-1][1]),costs[n-1][2]);
}

// 276

public int numWays(int n, int k) {
    if(n==0 || k == 0) return  0;
    
    int[] dp = new int[n+1];
    
    for(int i = 1;i<=n;i++){
        if(i == 1) dp[i] = k;
        else if(i == 2) dp[i] = k*k;
        else{
            dp[i] = (dp[i-1] + dp[i-2]) * (k-1);
        }
    }
    
    return dp[n];
}

// 121
public int maxProfit(int[] arr) {
    if(arr.length==0) return 0;

    int T0 = 0;
    int T1 = -(int)1e9;

    for(int val : arr){
        T0 = Math.max(T0,T1 + val);
        T1 = Math.max(T1,0 - val);
    }

    return T0;
}

//122
public int maxProfit(int[] arr) {
    if(arr.length==0) return 0;

    int T0 = 0;
    int T1 = -(int)1e9;

    for(int val : arr){
        T0 = Math.max(T0,T1 + val);
        T1 = Math.max(T1,T0 - val);
    }

    return T0;        
}

//309
public int maxProfit(int[] arr) {
    if(arr.length==0) return 0;

    int T0 = 0;
    int T1 = -(int)1e9;
    int T2 = 0;

    for(int val : arr){
        int temp = T0;
        T0 = Math.max(T0,T1 + val);
        T1 = Math.max(T1,T2 - val);
        T2 = temp;
    }

    return T0;        
}

//123
public int maxProfit(int[] arr) {
    if(arr.length==0) return 0;

    int T10 = 0;   // ek transaction pe holding zero 
    int T11 = -(int)1e9; // ek transaction pe holding ek ki hai.
   
    int T20 = 0;// do transaction pe holding zero 
    int T21 = -(int)1e9; // do transaction pe holding ek ki hai.
    
    for(int val : arr){
        T20 = Math.max(T20,T21 + val);
        T21 = Math.max(T21,T10 - val);

        T10 = Math.max(T10,T11 + val);
        T11 = Math.max(T11, 0 - val);
    }

    return T20;        
}

//188
public int maxProfit(int k, int[] prices) {
    if(prices.length==0) return 0;
    
    if(k > (prices.length >>> 1 )){
        
    int T0 = 0;
    int T1 = -(int)1e9;

    for(int val : prices){
        T0 = Math.max(T0,T1 + val);
        T1 = Math.max(T1,T0 - val);
    }

    return T0; 
    }
    
    int[] Ti0 = new int[k + 1];
    int[] Ti1 = new int[k + 1];
    Arrays.fill(Ti1,-(int)1e9);

    for(int val : prices){
        for(int K = k;K > 0; K--){
            Ti0[K] = Math.max(Ti0[K],Ti1[K] + val);
            Ti1[K] = Math.max(Ti1[K],Ti0[K - 1] - val);
        }
    }

    return Ti0[k];
}

//714
public int maxProfit(int[] prices, int fee) {
        
    int T0 = 0;
    int T1 = -(int)1e9;

    for(int val : prices){
        int T0_prev = T0; 
        T0 = Math.max(T0,T1 + val);
        T1 = Math.max(T1,T0_prev - val - fee);
    }

    return T0; 
        
}

//https://practice.geeksforgeeks.org/problems/consecutive-1s-not-allowed1912/1
long countStrings(int n) {
    if(n == 0) return n;
    
    long mod = (int)1e9 + 7;
    long zeros = 1;
    long onces = 1;
    for(int i = 1;i < n;i++){
        long prevZero = zeros;
        zeros = (zeros%mod + onces%mod)%mod;
        onces = prevZero%mod;
    }
    
    return (zeros%mod + onces%mod)%mod;
}

//https://www.geeksforgeeks.org/count-possible-ways-to-construct-buildings/


//887
public int superEggDrop(int K, int N,int[][] dp) {
    if(N <= 2) return dp[N][K] = N;
    if(K == 1) return dp[N][K] =N;
    
    if(dp[N][K]!=0) return dp[N][K];
    
    int ans = (int)1e8, lo = 1, hi = N;
    while(lo <= hi){
        
        int mid = (lo + hi) >> 1;
        int EggBreak = superEggDrop(K-1,mid-1,dp);
        int EggNotBreak = superEggDrop(K,N- mid,dp);
        
        if(EggBreak < EggNotBreak) lo = mid + 1;
        else hi = mid - 1;
        
        ans = Math.min(ans, 1 + Math.max(EggBreak,EggNotBreak));
    }
    
    return dp[N][K] = ans;
}

public int superEggDrop(int K, int N) {
    int[][] dp = new int[N+1][K+1];
    
    return superEggDrop(K,N,dp);
}


public class revision{
    
    public static void print(int[] arr){
        for(int ele: arr)
        System.out.print(ele+" ");

        System.out.println();
    }

    public static void print2D(int[][] arr){
        for(int[] ar: arr) print(ar);
        System.out.println();
    }


    public static int mazePath_Multi(int sr,int sc,int er,int ec,int[][] dp,int[][] dir){
        if(sr==er && sc == ec){
            return dp[sr][sc] = 1;
        }

        if(dp[sr][sc]!=0) return dp[sr][sc];
        
        int count = 0;
        for(int d = 0; d<dir.length;d++){   
           for(int jump = 1;jump <= Math.max(er,ec) ; jump++){
               int r = sr + jump*dir[d][0];
               int c = sc + jump*dir[d][1];

               if(r>=0 && c>=0 && r <= er && c<=ec)
                  count+=mazePath_Multi(r,c,er,ec,dp,dir);
               else break;
           }
        }

        return dp[sr][sc] = count;
    }

    public static int mazePath_MultiDP(int sr,int sc,int er,int ec,int[][] dp,int[][] dir){
               
        for(sr = er ; sr>=0 ; sr--){
            for(sc = ec; sc>=0 ; sc--){
                if(sr==er && sc == ec){
                   dp[sr][sc] = 1;
                   continue;
                }
        
                
                int count = 0;
                for(int d = 0; d<dir.length;d++){   
                   for(int jump = 1;jump <= Math.max(er,ec) ; jump++){
                       int r = sr + jump*dir[d][0];
                       int c = sc + jump*dir[d][1];
        
                       if(r>=0 && c>=0 && r <= er && c<=ec)
                          count+=dp[r][c];
                       else break;
                   }
                }
        
                dp[sr][sc] = count;
            }
        }

        return dp[0][0];
    }

    public static int boardPath(int sp,int ep,int[] dp){
        if(sp==ep){
            return dp[sp] = 1;
        }

        int count = 0;
        for(int dice = 1;dice <= 6 && sp+dice <=ep;dice++){
            count+= boardPath(sp+dice,ep,dp);
        }

        return dp[sp] = count;
    }

    public static int boardPath_DP(int sp,int ep,int[] dp){

        for(sp=ep; sp >= 0 ; sp--){
            if(sp==ep){
                dp[sp] = 1;
                continue;
            }
    
            int count = 0;
            for(int dice = 1;dice <= 6 && sp+dice <= ep;dice++){
                count+= dp[sp + dice];//boardPath(sp+dice,ep,dp);
            }
    
            dp[sp] = count;            
        }

        return dp[0];
    }
    
    public int minCostClimbingStairs(int[] cost,int n,int[] dp){
          if(n<=1){
            return dp[n] = cost[n]; 
          }

          if(dp[n]!=0) return dp[n];

          int a = minCostClimbingStairs(cost, n-1,dp);
          int b = minCostClimbingStairs(cost, n-2,dp);

          return Math.min(a,b) + (n != cost.length ? cost[n] : 0);
    }

    public int minCostClimbingStairs(int[] cost,int n,int[] dp){
        
        int N = n;
        for(n = 0; n <= N ; n++){
            if(n<=1){
                dp[n] = cost[n];
                continue;
              }
    
              int a = dp[n-1]; //minCostClimbingStairs(cost, n-1,dp);
              int b = dp[n-2]; //minCostClimbingStairs(cost, n-2,dp);
    
              Math.min(a,b) + (n != cost.length ? cost[n] : 0);
        
        }

        return dp[N];
    }

    //geeksforgeeks.org/friends-pairing-problem/
    public static int frindsPairing(int n,int[] dp){
        if(n<=1) {
            return dp[n] = 1;
        }

        if(dp[n]!=0) return dp[n];

        int single = frindsPairing(n-1,dp);
        int pairUp = frindsPairing(n-2,dp) * (n-1);
        
        return dp[n] = single + pairUp;
    }

    public static int frindsPairing_DP(int n,int[] dp){
        int N = n;
        for(n=0;n<=N;n++){
            if(n<=1) {
                dp[n] = 1;
                continue;
            }
    
            int single = dp[n-1];
            int pairUp = dp[n-2] * (n-1);
            
            dp[n] = single + pairUp;
        }

        return dp[N];

    }



    public  int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] dp = new int[cost.length + 1];
        int ans = minCostClimbingStairs(cost,n,dp);
        // int ans = minCostClimbingStairs_DP(cost,n,dp);
        return ans;
    }

    public static void Basic(){   
        // int n=5;
        // int[][] dp =new int[n][n];
        // int[][] dir = {{1,0},{0,1},{1,1}};
        // System.out.println(mazePath_Multi(0,0,n-1,n-1,dp,dir));
        // System.out.println(mazePath_MultiDP(0,0,n-1,n-1,dp,dir));
        
        int n = 10;
        int[] dp = new int[n+1];
        // System.out.println(boardPath(0,n,dp));
        System.out.println(boardPath_DP(0,n,dp));
        
        print(dp);
        // print2D(dp);
    }


    public static void solve(){
        Basic();
    }

    public static void main(String[] args){
        solve();
    }



} */